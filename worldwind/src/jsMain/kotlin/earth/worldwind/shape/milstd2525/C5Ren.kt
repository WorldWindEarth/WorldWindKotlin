// Generated by Karakum - do not modify it manually!

@file:JsModule("@armyc2.c5isr.renderer/mil-sym-ts-web")
@file:JsNonModule
@file:Suppress("NON_EXTERNAL_DECLARATION_IN_INAPPROPRIATE_FILE")
@file:OptIn(ExperimentalJsCollectionsApi::class)

package earth.worldwind.shape.milstd2525

import kotlin.js.Date
import kotlin.js.Promise
import kotlin.js.collections.JsReadonlyArray
import kotlin.js.collections.JsReadonlyMap
import org.w3c.dom.CanvasRenderingContext2D
import org.w3c.dom.ImageBitmap
import org.w3c.dom.HTMLCanvasElement

// Generated by dts-bundle-generator v9.5.1
typealias int = Number

typealias float = Number

typealias double = Number

external class POINT2 {
    constructor ()
    constructor (pt: POINT2)
    constructor (x: double, y: double)
    constructor (x: double, y: double, style: int)
    constructor (x: double, y: double, segment: int, style: int)

    var x: double
    var y: double
    var style: int
    var segment: int
    fun getX(): Number
    fun getY(): Number
}

/**
 * The <code>Point2D</code> class defines a point representing a location in
 *
 * <p>
 * This class is only the abstract superclass for all objects that store a 2D
 * coordinate. The actual storage representation of the coordinates is left to
 * the subclass.
 *
 * @author Jim Graham
 * @since 1.2
 */
external class Point2D {
    /**
     * Constructs and initializes a <code>Point2D</code> with coordinates
     * (0,&nbsp;0).
     *
     * @since 1.2
     */
    constructor ()

    /**
     * add the constructor
     * @param pt
     */
    constructor (pt: POINT2)

    /**
     * Constructs and initializes a <code>Point2D</code> with the specified
     * coordinates.
     *
     * @param x
     * the X coordinate of the newly constructed
     * <code>Point2D</code>
     * @param y
     * the Y coordinate of the newly constructed
     * <code>Point2D</code>
     * @since 1.2
     */
    constructor (x: double, y: double)

    /**
     * The X coordinate of this <code>Point2D</code>.
     *
     * @since 1.2
     */
    var x: double

    /**
     * The Y coordinate of this <code>Point2D</code>.
     *
     * @since 1.2
     */
    var y: double

    /**
     * {@inheritDoc}
     *
     * @since 1.2
     */
    fun getX(): double

    /**
     * {@inheritDoc}
     *
     * @since 1.2
     */
    fun getY(): double
    fun clone(): Point2D

    /**
     * Sets the location of this <code>Point2D</code> to the same coordinates as
     * the specified <code>Point2D</code> object.
     *
     * @param p
     * the specified <code>Point2D</code> to which to set this
     * <code>Point2D</code>
     * @since 1.2
     */
    fun setLocation(p: Point2D): Unit

    /**
     * Sets the location of this <code>Point2D</code> to the specified
     * <code>double</code> coordinates.
     *
     * @param x
     * the new X coordinate of this {Point2D}
     * @param y
     * the new Y coordinate of this {Point2D}
     * @since 1.2
     */
    fun setLocation(x: double, y: double): Unit

    /**
     * Returns the distance from this <code>Point2D</code> to
     * a specified point.
     *
     * @param px the X coordinate of the specified point to be measured
     *           against this <code>Point2D</code>
     * @param py the Y coordinate of the specified point to be measured
     *           against this <code>Point2D</code>
     * @return the distance between this <code>Point2D</code>
     * and a specified point.
     * @since 1.2
     */
    fun distance(px: double, py: double): Number

    /**
     * Determines whether or not two points are equal. Two instances of
     * <code>Point2D</code> are equal if the values of their <code>x</code> and
     * <code>y</code> member fields, representing their position in the
     * coordinate space, are the same.
     *
     * @param obj
     * an object to be compared with this <code>Point2D</code>
     * @return <code>true</code> if the object to be compared is an instance of
     * <code>Point2D</code> and has the same values; <code>false</code>
     * otherwise.
     * @since 1.2
     */
    fun equals(obj: Point2D): Boolean

    companion object {
        /**
         * Returns the square of the distance between two points.
         *
         * @param x1
         * the X coordinate of the first specified point
         * @param y1
         * the Y coordinate of the first specified point
         * @param x2
         * the X coordinate of the second specified point
         * @param y2
         * the Y coordinate of the second specified point
         * @return the square of the distance between the two sets of specified
         * coordinates.
         * @since 1.2
         */
        fun distanceSq(x1: double, y1: double, x2: double, y2: double): double

        /**
         * Returns the distance between two points.
         *
         * @param x1
         * the X coordinate of the first specified point
         * @param y1
         * the Y coordinate of the first specified point
         * @param x2
         * the X coordinate of the second specified point
         * @param y2
         * the Y coordinate of the second specified point
         * @return the distance between the two sets of specified coordinates.
         * @since 1.2
         */
        fun distance(x1: double, y1: double, x2: double, y2: double): double
    }
}

/**
 *
 *
 */
external class Point {
    constructor ()
    constructor (x1: Number, y1: Number)

    var x: Number
    var y: Number
    fun getX(): Number
    fun getY(): Number
    fun setLocation(x1: Number, y1: Number): Unit

    /**
     * Returns a string representing one of the shape types
     * from "armyc2.c2sd.renderer.so.ShapeTypes"
     * @returns {String}
     */
    fun getShapeType(): String

    /**
     * move x & y by specified amounts.
     * @param {Number} x shift x point by this value
     * @param {Number} y shift y point by this value
     * @returns {void}
     */
    fun shift(x: Number, y: Number): Unit

    /**
     * @returns {String} like "{x:#,y:#}"
     */
    fun toStringFormatted(): String

    /**
     * Makes a copy of this point object.
     * @returns {armyc2.c2sd.renderer.so.Point} Copy of original point.
     */
    fun clone(): Point
    fun toPoint2D(): Point2D

    /**
     * @param {CanvasRenderingContext2D} context object from html5 canvas
     * @returns {void}
     */
    fun setPath(context: CanvasRenderingContext2D): Unit

    /**
     * @param {context} context object from html5 canvas
     * @returns {void}
     */
    fun stroke(context: CanvasRenderingContext2D): Unit

    /**
     * @param {context} context object from html5 canvas
     * @returns {void}
     */
    fun fill(context: CanvasRenderingContext2D): Unit
}

external class Line2D {
    /**
     * Constructs and initializes a Line with coordinates (0, 0) -&gt; (0, 0).
     *
     * @since 1.2
     */
    constructor ()

    /**
     * Constructs and initializes a <code>Line2D</code> from the specified
     * <code>Point2D</code> objects.
     *
     * @param p1
     * the start <code>Point2D</code> of this line segment
     * @param p2
     * the end <code>Point2D</code> of this line segment
     * @since 1.2
     */
    constructor (p1: Point2D, p2: Point2D)

    /**
     * Constructs and initializes a <code>Line2D</code> from the specified
     * coordinates.
     *
     * @param x1
     * the X coordinate of the start point
     * @param y1
     * the Y coordinate of the start point
     * @param x2
     * the X coordinate of the end point
     * @param y2
     * the Y coordinate of the end point
     * @since 1.2
     */
    constructor (x1: double, y1: double, x2: double, y2: double)

    fun intersectsLine(edge: Line2D): Boolean

    /**
     * The X coordinate of the start point of the line segment.
     *
     * @since 1.2
     * @serial
     */
    var x1: double

    /**
     * The Y coordinate of the start point of the line segment.
     *
     * @since 1.2
     * @serial
     */
    var y1: double

    /**
     * The X coordinate of the end point of the line segment.
     *
     * @since 1.2
     * @serial
     */
    var x2: double

    /**
     * The Y coordinate of the end point of the line segment.
     *
     * @since 1.2
     * @serial
     */
    var y2: double

    /**
     * {@inheritDoc}
     *
     * @since 1.2
     */
    fun getX1(): double

    /**
     * {@inheritDoc}
     *
     * @since 1.2
     */
    fun getY1(): double

    /**
     * {@inheritDoc}
     *
     * @since 1.2
     */
    fun getP1(): Point2D

    /**
     * {@inheritDoc}
     *
     * @since 1.2
     */
    fun getX2(): double

    /**
     * {@inheritDoc}
     *
     * @since 1.2
     */
    fun getY2(): double

    /**
     * {@inheritDoc}
     *
     * @since 1.2
     */
    fun getP2(): Point2D

    /**
     * {@inheritDoc}
     *
     * @since 1.2
     */
    fun getBounds2D(): Rectangle2D

    /**
     * Sets the location of the end points of this <code>Line2D</code> to the
     * same as those end points of the specified <code>Line2D</code>.
     *
     * @param l
     * the specified <code>Line2D</code>
     * @since 1.2
     */
    fun setLine(l: Line2D): Unit

    /**
     * Sets the location of the end points of this <code>Line2D</code> to the
     * specified <code>Point2D</code> coordinates.
     *
     * @param p1
     * the start <code>Point2D</code> of the line segment
     * @param p2
     * the end <code>Point2D</code> of the line segment
     * @since 1.2
     */
    fun setLine(p1: Point2D, p2: Point2D): Unit

    /**
     * Sets the location of the end points of this <code>Line2D</code> to the
     * specified double coordinates.
     *
     * @param x1
     * the X coordinate of the start point
     * @param y1
     * the Y coordinate of the start point
     * @param x2
     * the X coordinate of the end point
     * @param y2
     * the Y coordinate of the end point
     * @since 1.2
     */
    fun setLine(x1: double, y1: double, x2: double, y2: double): Unit

    /**
     * Returns an indicator of where the specified point {@code (px,py)} lies
     * with respect to this line segment. See the method comments of
     * {@link #relativeCCW(double, double, double, double, double, double)} to
     * interpret the return value.
     *
     * @param px
     * the X coordinate of the specified point to be compared with
     * this <code>Line2D</code>
     * @param py
     * the Y coordinate of the specified point to be compared with
     * this <code>Line2D</code>
     * @return an integer that indicates the position of the specified
     * coordinates with respect to this <code>Line2D</code>
     * @see #relativeCCW(double, double, double, double, double, double)
     * @since 1.2
     */
    fun relativeCCW(px: double, py: double): int

    /**
     * Returns the square of the distance from a specified <code>Point2D</code>
     * to this line. The distance measured is the distance between the specified
     * point and the closest point on the infinitely-extended line defined by
     * this <code>Line2D</code>. If the specified point intersects the line,
     * this method returns 0.0.
     *
     * @param pt
     * the specified <code>Point2D</code> being measured against this
     * line
     * @return a double value that is the square of the distance from a
     * specified <code>Point2D</code> to the current line.
     * @since 1.2
     */
    fun ptLineDistSq(pt: Point2D): double

    /**
     * Returns the square of the distance from a point to this line. The
     * distance measured is the distance between the specified point and the
     * closest point on the infinitely-extended line defined by this
     * <code>Line2D</code>. If the specified point intersects the line, this
     * method returns 0.0.
     *
     * @param px
     * the X coordinate of the specified point being measured against
     * this line
     * @param py
     * the Y coordinate of the specified point being measured against
     * this line
     * @return a double value that is the square of the distance from a
     * specified point to the current line.
     * @since 1.2
     */
    fun ptLineDistSq(px: double, py: double): double

    /**
     * Returns the distance from a <code>Point2D</code> to this line. The
     * distance measured is the distance between the specified point and the
     * closest point on the infinitely-extended line defined by this
     * <code>Line2D</code>. If the specified point intersects the line, this
     * method returns 0.0.
     *
     * @param pt
     * the specified <code>Point2D</code> being measured
     * @return a double value that is the distance from a specified
     * <code>Point2D</code> to the current line.
     * @since 1.2
     */
    fun ptLineDist(pt: Point2D): double

    /**
     * Returns the distance from a point to this line. The distance measured is
     * the distance between the specified point and the closest point on the
     * infinitely-extended line defined by this <code>Line2D</code>. If the
     * specified point intersects the line, this method returns 0.0.
     *
     * @param px
     * the X coordinate of the specified point being measured against
     * this line
     * @param py
     * the Y coordinate of the specified point being measured against
     * this line
     * @return a double value that is the distance from a specified point to the
     * current line.
     * @since 1.2
     */
    fun ptLineDist(px: double, py: double): double

    /**
     * Tests if a given <code>Point2D</code> is inside the boundary of this
     * <code>Line2D</code>. This method is required to implement the
     * {@link Shape} interface, but in the case of <code>Line2D</code> objects
     * it always returns <code>false</code> since a line contains no area.
     *
     * @param p
     * the specified <code>Point2D</code> to be tested
     * @return <code>false</code> because a <code>Line2D</code> contains no
     * area.
     * @since 1.2
     */
    fun contains(p: Point2D): Boolean

    /**
     * Tests if the interior of this <code>Line2D</code> entirely contains the
     * specified <code>Rectangle2D</code>. This method is required to implement
     * the <code>Shape</code> interface, but in the case of <code>Line2D</code>
     * objects it always returns <code>false</code> since a line contains no
     * area.
     *
     * @param r
     * the specified <code>Rectangle2D</code> to be tested
     * @return <code>false</code> because a <code>Line2D</code> contains no
     * area.
     * @since 1.2
     */
    fun contains(r: Rectangle2D): Boolean

    /**
     * Tests if a specified coordinate is inside the boundary of this
     * <code>Line2D</code>. This method is required to implement the
     * {@link Shape} interface, but in the case of <code>Line2D</code> objects
     * it always returns <code>false</code> since a line contains no area.
     *
     * @param x
     * the X coordinate of the specified point to be tested
     * @param y
     * the Y coordinate of the specified point to be tested
     * @return <code>false</code> because a <code>Line2D</code> contains no
     * area.
     * @since 1.2
     */
    fun contains(x: double, y: double): Boolean

    /**
     * Tests if the interior of this <code>Line2D</code> entirely contains the
     * specified set of rectangular coordinates. This method is required to
     * implement the <code>Shape</code> interface, but in the case of
     * <code>Line2D</code> objects it always returns false since a line contains
     * no area.
     *
     * @param x
     * the X coordinate of the upper-left corner of the specified
     * rectangular area
     * @param y
     * the Y coordinate of the upper-left corner of the specified
     * rectangular area
     * @param w
     * the width of the specified rectangular area
     * @param h
     * the height of the specified rectangular area
     * @return <code>false</code> because a <code>Line2D</code> contains no
     * area.
     * @since 1.2
     */
    fun contains(x: double, y: double, w: double, h: double): Boolean

    /**
     * Creates a new object of the same class as this object.
     *
     * @return a clone of this instance.
     * @exception OutOfMemoryError
     * if there is not enough memory.
     * @see java.lang.Cloneable
     * @since 1.2
     */
    fun clone(): Line2D?

    companion object {
        fun linesIntersect(
            x1: double,
            y1: double,
            x2: double,
            y2: double,
            x3: double,
            y3: double,
            x4: double,
            y4: double
        ): Boolean

        /**
         * Returns an indicator of where the specified point {@code (px,py)} lies
         * with respect to the line segment from {@code (x1,y1)} to {@code (x2,y2)}.
         * The return value can be either 1, -1, or 0 and indicates in which
         * direction the specified line must pivot around its first end point,
         * {@code (x1,y1)}, in order to point at the specified point {@code (px,py)}
         * .
         * <p>
         * A return value of 1 indicates that the line segment must turn in the
         * direction that takes the positive X axis towards the negative Y axis. In
         * the default coordinate system used by Java 2D, this direction is
         * counterclockwise.
         * <p>
         * A return value of -1 indicates that the line segment must turn in the
         * direction that takes the positive X axis towards the positive Y axis. In
         * the default coordinate system, this direction is clockwise.
         * <p>
         * A return value of 0 indicates that the point lies exactly on the line
         * segment. Note that an indicator value of 0 is rare and not useful for
         * determining colinearity because of floating point rounding issues.
         * <p>
         * If the point is colinear with the line segment, but not between the end
         * points, then the value will be -1 if the point lies "beyond {@code
         * (x1,y1)}" or 1 if the point lies "beyond {@code (x2,y2)}".
         *
         * @param x1
         * the X coordinate of the start point of the specified line
         * segment
         * @param y1
         * the Y coordinate of the start point of the specified line
         * segment
         * @param x2
         * the X coordinate of the end point of the specified line
         * segment
         * @param y2
         * the Y coordinate of the end point of the specified line
         * segment
         * @param px
         * the X coordinate of the specified point to be compared with
         * the specified line segment
         * @param py
         * the Y coordinate of the specified point to be compared with
         * the specified line segment
         * @return an integer that indicates the position of the third specified
         * coordinates with respect to the line segment formed by the first
         * two specified coordinates.
         * @since 1.2
         */
        fun relativeCCW(x1: double, y1: double, x2: double, y2: double, px: double, py: double): int

        /**
         * Returns the square of the distance from a point to a line. The distance
         * measured is the distance between the specified point and the closest
         * point on the infinitely-extended line defined by the specified
         * coordinates. If the specified point intersects the line, this method
         * returns 0.0.
         *
         * @param x1
         * the X coordinate of the start point of the specified line
         * @param y1
         * the Y coordinate of the start point of the specified line
         * @param x2
         * the X coordinate of the end point of the specified line
         * @param y2
         * the Y coordinate of the end point of the specified line
         * @param px
         * the X coordinate of the specified point being measured against
         * the specified line
         * @param py
         * the Y coordinate of the specified point being measured against
         * the specified line
         * @return a double value that is the square of the distance from the
         * specified point to the specified line.
         * @since 1.2
         */
        fun ptLineDistSq(x1: double, y1: double, x2: double, y2: double, px: double, py: double): double

        /**
         * Returns the distance from a point to a line. The distance measured is the
         * distance between the specified point and the closest point on the
         * infinitely-extended line defined by the specified coordinates. If the
         * specified point intersects the line, this method returns 0.0.
         *
         * @param x1
         * the X coordinate of the start point of the specified line
         * @param y1
         * the Y coordinate of the start point of the specified line
         * @param x2
         * the X coordinate of the end point of the specified line
         * @param y2
         * the Y coordinate of the end point of the specified line
         * @param px
         * the X coordinate of the specified point being measured against
         * the specified line
         * @param py
         * the Y coordinate of the specified point being measured against
         * the specified line
         * @return a double value that is the distance from the specified point to
         * the specified line.
         * @since 1.2
         */
        fun ptLineDist(x1: double, y1: double, x2: double, y2: double, px: double, py: double): double
    }
}

/**
 *
 *
 */
external class Rectangle2D {
    constructor ()
    constructor (x1: double, y1: double, width1: double, height1: double)

    var x: double
    var y: double
    var width: double
    var height: double
    fun add(newx: double, newy: double): Unit
    fun createIntersection(r: Rectangle2D): Rectangle2D?
    fun createUnion(r: Rectangle2D): Rectangle2D
    fun getX(): double
    fun getY(): double
    fun getCenterX(): double
    fun getCenterY(): double
    fun getMinX(): double
    fun getMinY(): double
    fun getMaxX(): double
    fun getMaxY(): double
    fun getHeight(): double
    fun getWidth(): double
    fun contains(rect: Rectangle2D): Boolean
    fun contains(pt: Point2D): Boolean
    fun contains(x1: double, y1: double): Boolean
    fun contains(x: int, y: int, width: int, height: int): Boolean
    fun intersects(rect: Rectangle2D): Boolean
    fun intersects(x1: int, y1: int, width1: int, height1: int): Boolean
    fun intersectsLine(line: Line2D): Boolean
    fun isEmpty(): Boolean
    fun setRect(r: Rectangle2D): Unit
    fun setRect(x1: double, y1: double, width1: double, height1: double): Unit
    fun grow(size: int): Any?
    fun grow(h: int, v: int): Any?
    fun stroke(context: CanvasRenderingContext2D): Unit
    fun fill(context: CanvasRenderingContext2D): Unit
    fun clone(): Rectangle2D

    /**
     * Will merge the bounds of two rectangle.
     * @param rect
     */
    fun union(rect: Rectangle2D): Unit

    /**
     *
     * @param stroke named color or hex color
     * @param strokeWidth width of line in # of pixels
     * @param fill named color or hex color
     * @returns
     */
    fun toSVGElement(stroke: String?, strokeWidth: Number, fill: String?): String
}

/**
 *
 *
 */
external class Font {
    constructor (s: String, type: Number, size: Number)

    var _size: Number
    var _text: String
    var _type: Number
    fun getSize(): Number
    fun getName(): String
    fun getType(): Number
    fun isBold(): Boolean
    fun getTypeString(): String

    companion object {
        val PLAIN: Number
        val BOLD: Number
        val ITALIC: Number
        fun getTypeString(type: Number): String
        fun getTypeInt(type: String): Number
    }
}

/**
 * Default Affiliation Colors for the symbols
 */
external object AffiliationColors {
	var FriendlyUnitFillColor: Color
	var HostileUnitFillColor: Color
	var NeutralUnitFillColor: Color
	var UnknownUnitFillColor: Color
	var SuspectUnitFillColor: Color

	var FriendlyGraphicFillColor: Color
	var HostileGraphicFillColor: Color
	var NeutralGraphicFillColor: Color
	var UnknownGraphicFillColor: Color
	var SuspectGraphicFillColor: Color

	var FriendlyUnitLineColor: Color
	var HostileUnitLineColor: Color
	var NeutralUnitLineColor: Color
	var UnknownUnitLineColor: Color
	var SuspectUnitLineColor: Color

	var FriendlyGraphicLineColor: Color
	var HostileGraphicLineColor: Color
	var NeutralGraphicLineColor: Color
	var UnknownGraphicLineColor: Color
    var SuspectGraphicLineColor: Color

	var ObstacleGreenDark: Color
	var ObstacleGreen: Color

	var WeatherRed: Color
	var WeatherBlue: Color

	var WeatherPurpleDark: Color
	var WeatherPurpleLight: Color

	var WeatherBrownDark: Color
	var WeatherBrownLight: Color
}

/**
 * Integer based Color class with utility functions
 */
external class Color {
    constructor ()
    constructor (color: Color)
    constructor (color: Number)
    constructor (R: Number, G: Number, B: Number)
    constructor (R: Number, G: Number, B: Number, A: Number)
    constructor (hexString: String)

    fun toRGB(): Number
    fun toARGB(): Number

    /**
     * A hex string in the format of AARRGGBB
     * @param {Boolean} withAlpha Optional, default is true. If set to false,
     * will return a hex string without alpha values.
     */
    fun toHexString(withAlpha: Boolean = definedExternally): String
    fun getRed(): Number
    fun getGreen(): Number
    fun getBlue(): Number
    fun getAlpha(): Number

    /**
     *
     * @param alpha 0-255
     */
    fun setAlpha(alpha: Number): Unit
    fun toInt(): Number

    companion object {
        /**
         * The color white.  In the default sRGB space.
         */
        val white: Color

        /**
         * The color white.  In the default sRGB space.
         *
         */
        val WHITE: Color

        /**
         * The color light gray.  In the default sRGB space.
         */
        val lightGray: Color

        /**
         * The color light gray.  In the default sRGB space.
         *
         */
        val LIGHT_GRAY: Color

        /**
         * The color gray.  In the default sRGB space.
         */
        val gray: Color

        /**
         * The color gray.  In the default sRGB space.
         *
         */
        val GRAY: Color

        /**
         * The color dark gray.  In the default sRGB space.
         */
        val darkGray: Color

        /**
         * The color dark gray.  In the default sRGB space.
         *
         */
        val DARK_GRAY: Color

        /**
         * The color black.  In the default sRGB space.
         */
        val black: Color

        /**
         * The color black.  In the default sRGB space.
         *
         */
        val BLACK: Color

        /**
         * The color red.  In the default sRGB space.
         */
        val red: Color

        /**
         * The color red.  In the default sRGB space.
         *
         */
        val RED: Color

        /**
         * The color pink.  In the default sRGB space.
         */
        val pink: Color

        /**
         * The color pink.  In the default sRGB space.
         *
         */
        val PINK: Color

        /**
         * The color orange.  In the default sRGB space.
         */
        val orange: Color

        /**
         * The color orange.  In the default sRGB space.
         *
         */
        val ORANGE: Color

        /**
         * The color yellow.  In the default sRGB space.
         */
        val yellow: Color

        /**
         * The color yellow.  In the default sRGB space.
         *
         */
        val YELLOW: Color

        /**
         * The color green.  In the default sRGB space.
         */
        val green: Color

        /**
         * The color green.  In the default sRGB space.
         *
         */
        val GREEN: Color

        /**
         * The color magenta.  In the default sRGB space.
         */
        val magenta: Color

        /**
         * The color magenta.  In the default sRGB space.
         *
         */
        val MAGENTA: Color

        /**
         * The color cyan.  In the default sRGB space.
         */
        val cyan: Color

        /**
         * The color cyan.  In the default sRGB space.
         *
         */
        val CYAN: Color

        /**
         * The color blue.  In the default sRGB space.
         */
        val blue: Color

        /**
         * The color blue.  In the default sRGB space.
         *
         */
        val BLUE: Color
        fun makeColor(r: Number, g: Number, b: Number): Color
    }
}

/**
 * Port of java.util.logging.Level class
 */
external class LogLevel {
    constructor (name: String, value: Number)

    fun intValue(): Number
    fun getName(): String

    companion object {
        /**
         * OFF is a special level that can be used to turn off logging.
         * This level is initialized to <CODE>Integer.MAX_VALUE</CODE>.
         */
        var OFF: LogLevel

        /**
         * SEVERE is a message level indicating a serious failure.
         * <p>
         * In general SEVERE messages should describe events that are
         * of considerable importance and which will prevent normal
         * program execution.   They should be reasonably intelligible
         * to end users and to system administrators.
         * This level is initialized to <CODE>1000</CODE>.
         */
        var SEVERE: LogLevel

        /**
         * WARNING is a message level indicating a potential problem.
         * <p>
         * In general WARNING messages should describe events that will
         * be of interest to end users or system managers, or which
         * indicate potential problems.
         * This level is initialized to <CODE>900</CODE>.
         */
        var WARNING: LogLevel

        /**
         * INFO is a message level for informational messages.
         * <p>
         * Typically INFO messages will be written to the console
         * or its equivalent.  So the INFO level should only be
         * used for reasonably significant messages that will
         * make sense to end users and system administrators.
         * This level is initialized to <CODE>800</CODE>.
         */
        var INFO: LogLevel

        /**
         * CONFIG is a message level for static configuration messages.
         * <p>
         * CONFIG messages are intended to provide a variety of static
         * configuration information, to assist in debugging problems
         * that may be associated with particular configurations.
         * For example, CONFIG message might include the CPU type,
         * the graphics depth, the GUI look-and-feel, etc.
         * This level is initialized to <CODE>700</CODE>.
         */
        var CONFIG: LogLevel

        /**
         * FINE is a message level providing tracing information.
         * <p>
         * All of FINE, FINER, and FINEST are intended for relatively
         * detailed tracing.  The exact meaning of the three levels will
         * vary between subsystems, but in general, FINEST should be used
         * for the most voluminous detailed output, FINER for somewhat
         * less detailed output, and FINE for the  lowest volume (and
         * most important) messages.
         * <p>
         * In general the FINE level should be used for information
         * that will be broadly interesting to developers who do not have
         * a specialized interest in the specific subsystem.
         * <p>
         * FINE messages might include things like minor (recoverable)
         * failures.  Issues indicating potential performance problems
         * are also worth logging as FINE.
         * This level is initialized to <CODE>500</CODE>.
         */
        var FINE: LogLevel

        /**
         * FINER indicates a fairly detailed tracing message.
         * By default logging calls for entering, returning, or throwing
         * an exception are traced at this level.
         * This level is initialized to <CODE>400</CODE>.
         */
        var FINER: LogLevel

        /**
         * FINEST indicates a highly detailed tracing message.
         * This level is initialized to <CODE>300</CODE>.
         */
        var FINEST: LogLevel

        /**
         * ALL indicates that all messages should be logged.
         * This level is initialized to <CODE>Integer.MIN_VALUE</CODE>.
         */
        var ALL: LogLevel
    }
}

/**
 * Error Logging class for Renderer
 *
 */
external class ErrorLogger {

    companion object {
        val LoggerName: String

        /**
         * True if logging is enabled
         * @return {@link Boolean}
         */
        fun getLoggingStatus(): Boolean

        /**
         * Takes a throwable and puts it's stacktrace into a string.
         * @param error {@link Error}
         * @return {@link String}
         */
        fun getStackTrace(error: Error): String

        /**
         * TRUE: Creates a file handler that will log message to a file.
         * FALSE: logging just goes to console.
         * @param enable {@link Boolean}
         */
        fun EnableLogging(enable: Boolean): Unit

        /**
         * Folder location to store the log file.
         * Defaults to "System.getProperty("user.dir")"
         * @param path {@link String}
         * @deprecated
         */
        fun setLoggingPath(path: String): Unit

        /**
         * clears log files that are beyond a passed number of days old
         * @param DaysOld {@link Integer}
         * @deprecated
         */
        fun CleanupOldFiles(DaysOld: Number): Unit

        /**
         * Set minimum level at which an item can be logged.
         * In descending order:
         * Severe
         * Warning
         * Info
         * Config
         * Fine
         * Finer
         * Finest
         * @param newLevel {@link Level}
         */
        fun setLevel(newLevel: LogLevel): Unit

        /**
         * Set minimum level at which an item can be logged.
         * In descending order:
         * Severe
         * Warning
         * Info
         * Config
         * Fine
         * Finer
         * Finest
         * @param newLevel {@link Level}
         * @param setConsoleHandler logger could be set to FINE but the console
         * handler could be set to INFO.  In that case, anything logged at FINE
         * wouldn't show because it'd get blocked by the console handler.  Set to
         * "true" to make sure the console handler will let you log at the level
         * you want.  If you're only concerned with the log file, you can leave
         * "false"
         */
        fun setLevel(newLevel: LogLevel, setConsoleHandler: Boolean): Unit

        /**
         * Specify whether or not this logger should send its output
         * to it's parent Logger.  This means that any LogRecords will
         * also be written to the parent's Handlers, and potentially
         * to its parent, recursively up the namespace.
         * Defaults to true;
         *
         * @param useParentHandlers   true if output is to be sent to the
         *		logger's parent.
         */
        fun setUseParentHandlers(useParentHandlers: Boolean): Unit

        /**
         * Gets the java.util.logging.Level that the logger is set to.
         * @return {@link Level}
         */
        fun getLevel(): LogLevel

        /**
         * Log a method entry.
         * <p>
         * This is a convenience method that can be used to log entry
         * to a method.  A LogRecord with message "ENTRY", log level
         * FINER, and the given sourceMethod and sourceClass is logged.
         * <p>
         * @param   sourceClass    name of class that issued the logging request
         * @param   sourceMethod   name of method that is being entered
         */
        fun Entering(sourceClass: String, sourceMethod: String): Unit

        /**
         * Log a method entry, with one parameter.
         * <p>
         * This is a convenience method that can be used to log entry
         * to a method.  A LogRecord with message "ENTRY {0}", log level
         * FINER, and the given sourceMethod, sourceClass, and parameter
         * is logged.
         * <p>
         * @param   sourceClass    name of class that issued the logging request
         * @param   sourceMethod   name of method that is being entered
         * @param   param1           parameter to the method being entered
         */
        fun Entering(sourceClass: String, sourceMethod: String, param1: Any?): Unit

        /**
         * Log a method entry, with an array of parameters.
         * <p>
         * This is a convenience method that can be used to log entry
         * to a method.  A LogRecord with message "ENTRY" (followed by a
         * format {N} indicator for each entry in the parameter array),
         * log level FINER, and the given sourceMethod, sourceClass, and
         * parameters is logged.
         * <p>
         * @param   sourceClass    name of class that issued the logging request
         * @param   sourceMethod   name of method that is being entered
         * @param   params           array of parameters to the method being entered
         */
        fun Entering(sourceClass: String, sourceMethod: String, params: JsReadonlyArray<Any?>): Unit

        /**
         * Log a method return.
         * <p>
         * This is a convenience method that can be used to log returning
         * from a method.  A LogRecord with message "RETURN", log level
         * FINER, and the given sourceMethod and sourceClass is logged.
         * <p>
         * @param   sourceClass    name of class that issued the logging request
         * @param   sourceMethod   name of the method
         */
        fun Exiting(sourceClass: String, sourceMethod: String): Unit

        /**
         * Log a method return, with result object.
         * <p>
         * This is a convenience method that can be used to log returning
         * from a method.  A LogRecord with message "RETURN {0}", log level
         * FINER, and the gives sourceMethod, sourceClass, and result
         * object is logged.
         * <p>
         * @param   sourceClass    name of class that issued the logging request
         * @param   sourceMethod   name of the method
         * @param   result  Object that is being returned
         */
        fun Exiting(sourceClass: String, sourceMethod: String, result: Any?): Unit

        /**
         * Defaults to Level.INFO
         * @param message {@link String}
         */
        fun LogMessage(message: String): Unit

        /**
         * Defaults to Level.INFO
         * @param message {@link String}
         * @param showMessageBox (@link {@link Boolean}
         */
        fun LogMessage(message: String, showMessageBox: Boolean): Unit

        /**
         *
         * @param message {@link String}
         * @param lvl {@link Level}
         * @param showMessageBox {@link Boolean}
         */
        fun LogMessage(message: String, lvl: LogLevel, showMessageBox: Boolean): Unit
        fun LogMessage(sourceClass: String, sourceMethod: String, message: String): Unit
        fun LogMessage(sourceClass: String, sourceMethod: String, message: String, showMessageBox: Boolean): Unit
        fun LogMessage(sourceClass: String, sourceMethod: String, message: String, lvl: LogLevel): Unit
        fun LogMessage(
            sourceClass: String,
            sourceMethod: String,
            message: String,
            lvl: LogLevel,
            showMessageBox: Boolean
        ): Unit

        fun LogMessage(
            sourceClass: String,
            sourceMethod: String,
            message: String,
            lvl: LogLevel,
            param1: Any?,
            showMessageBox: Boolean
        ): Unit

        fun LogMessage(
            sourceClass: String,
            sourceMethod: String,
            message: String,
            lvl: LogLevel,
            params: JsReadonlyArray<Any?>,
            showMessageBox: Boolean
        ): Unit

        fun LogException(sourceClass: String, sourceMethod: String, exc: Error): Unit
        fun LogException(sourceClass: String, sourceMethod: String, exc: Error, showMessageBox: Boolean): Unit
        fun LogException(sourceClass: String, sourceMethod: String, exc: Error, lvl: LogLevel): Unit
        fun LogException(
            sourceClass: String,
            sourceMethod: String,
            exc: Error,
            lvl: LogLevel,
            showMessageBox: Boolean
        ): Unit

        fun PrintList(list: Array<Any?>): String
        fun PrintObjectMap(map: JsReadonlyMap<String, Any?>): String
        fun PrintStringMap(map: JsReadonlyMap<String, String>): String
    }
}

/**
 * Symbol attribute constants
 */
external class MilStdAttributes {

    companion object {
        /**
         * Line color of the symbol. hex value.
         */
        val LineColor: String

        /**
         * Fill color of the symbol. hex value
         */
        val FillColor: String

        /**
         * Main color of internal icon.  Only relevant to framed symbols. hex value
         */
        val IconColor: String

        /**
         * size of the single point image
         */
        val PixelSize: String

        /**
         * defaults to true
         */
        val KeepUnitRatio: String

        /**
         * transparency value of the symbol with values from 0 - 255.
         */
        val Alpha: String

        /**
         * outline the symbol, true/false
         */
        val OutlineSymbol: String

        /**
         * specify and outline color rather than letting renderer picking
         * the best contrast color. hex value
         */
        val OutlineColor: String

        /**
         * just draws the core symbol
         */
        val DrawAsIcon: String

        /**
         * Specifies the line width of the multipoint symbology
         */
        val LineWidth: String

        /**
         * Specifies the color for text labels
         */
        val TextColor: String

        /**
         * Specifies the color for the text background (color outline or fill)
         */
        val TextBackgroundColor: String

        /**
         * If false, the renderer will create a bunch of little lines to create
         * the "dash" effect (expensive but necessary for KML).
         * If true, it will be on the user to create the dash effect using the
         * DashArray from the Stroke object from the ShapeInfo object.
         */
        val UseDashArray: String

        /**
         * The mode that altitude labels will be displayed in, the default value is AMSL.
         *
         * This value acts as a label, appending whatever string that is passed in to the end of the altitude units.
         * Currently only effective for multi-point graphics.
         */
        val AltitudeMode: String

        /**
         * At the moment, this refers to the optional range fan labels.
         */
        val HideOptionalLabels: String

        /**
         * For internal use
         */
        val UsePatternFill: String

        /**
         * For internal use
         */
        val PatternFillType: String

        /**
         * The conversion factor and the label that you want all distances to display in. The conversion factor
         * is converting from meters. The default unit is meters.<br><br>
         *
         * Must be in the form [conversionFactor],[label]. So for example converting to feet would be "3.28084,FT".
         * The helper class {@link DistanceUnit} can be used.
         */
        val DistanceUnits: String

        /**
         * The conversion factor and the label that you want all distances to display in.
         * Conventionally, the conversion factor is converting from meters by default,
         * but other values could be passed, like "1,KM" to use an unaltered value in kilometers.<br><br>
         *
         * Must be in the form [conversionFactor],[label]. So for example converting meters to feet would be "3.28084,FT".
         * The helper class {@link DistanceUnit} can be used.
         * Currently only effective for multi-point graphics.
         */
        val AltitudeUnits: String

        /**
         * If the engagement/target amplifier bar is to be used to designate targets, non-targets, and
         * pruned or expired targets, a different coloring schema shall be used. Hostile tracks which
         * are deemed targets shall have a red bar (RGB: 255, 0, 0) to indicate target. For hostile
         * tracks deemed to be non-targets, white (RGB: 255, 255, 255) should be used to indicate non
         * target. Finally, for hostile tracks which have been pruned or have expired shall be colored
         * orange (RGB: 255, 120, 0).
         * This attribute expects a hex string for the color
         */
        val EngagementBarColor: String

        /**
         * No Longer relevant
         * @return
         * @deprecated see {@link GetAttributesList()}
         */
        fun GetModifierList(): Array<String>
        fun GetAttributesList(symbolID: String): Array<String>

        /**
         * @param attribute constant like MilStdAttributes.LineColor
         * @return attribute name based on attribute constants
         */
        fun getAttributeName(attribute: String): String

        /**
         * Takes a string representation of an attribute and returns the appropriate int key value
         * @param attribute "LINECOLOR" will return MilStdAtttributes.LineColor
         * @return number value representing Attribute constant.
         */
        fun getAttributeKey(attribute: String): String?
    }
}

/**
 * Modifier Constants to be used as keys in the modifiers map
 */
external class Modifiers {

    companion object {
        /**
         * <pre>
         * Symbol Icon
         * The innermost part of a symbol, comprised of an icon and optional modifiers, that represents a joint military object (see 5.3.4).
         * Format: Graphic
         * Symbol Set: All
         * Remarks: Determined by SIDC positions 11-20.
         * </pre>
         */
        val A_SYMBOL_ICON: String

        /**
         * <pre>
         * Echelon
         * An amplifier in a unit symbol that identifies command level (see 5.3.7.1 and table VII).
         * Format: Graphic
         * Symbol Set: All
         * Remarks: Determined by SIDC positions 9-10.
         * </pre>
         */
        val B_ECHELON: String

        /**
         * <pre>
         * Quantity
         * An amplifier in an equipment symbol that identifies the number of items present.
         * Examples include:
         * 350 Beds 50 Gallons
         * Format:
         * Alphanumeric - {1,19}
         * [#########] [XXXXXXXXXX]
         * Symbol Set: 10, 11, 15, 25, 27, 60
         * Remarks: Two-part composite field.
         * Where # is the numeric value [1-999999999], and X is the unit of measure.
         * Note: There should be a space between the numeric and the unit of measure values.
         * </pre>
         */
        val C_QUANTITY: String

        /**
         * <pre>
         * Task Force Indicator
         * An amplifier that identifies a unit or activities symbol as a task force (see 5.3.7.2 and figure 14).
         * Format: Graphic
         * Symbol Set: 10
         * Remarks: Determined by SIDC position 8.
         * </pre>
         */
        val D_TASK_FORCE_INDICATOR: String

        /**
         * <pre>
         * Frame Shape Modifier
         * A graphic modifier that displays standard identity, battle dimension, or exercise
         * amplifying descriptors of an object (see 5.3.1 and table II).
         * Format: Graphic
         * Symbol Set: ALL BUT 25,45,46,47
         * Remarks: 2525C, not processed as a modifier in 2525D+
         * </pre>
         */
        val E_FRAME_SHAPE_MODIFIER: String

        /**
         * <pre>
         * Reinforced or Reduced
         * An amplifier in a unit symbol that displays (+) for reinforced, (-) for reduced, (<u>+</u>) reinforced and reduced.
         * Format: Alphanumeric - {1,1}
         * Symbol Set: 10
         * Remarks:
         * </pre>
         */
        val F_REINFORCED_REDUCED: String

        /**
         * <pre>
         * Staff Comments
         * An amplifier for units, equipment and installations; content is implementation specific.
         * Format: Alphanumeric - {1,20}
         * Symbol Set: 01, 05, 10, 15, 20, 27, 30, 35, 40
         * Remarks:
         * </pre>
         */
        val G_STAFF_COMMENTS: String

        /**
         * <pre>
         * Additional Information
         * An amplifier for units, equipment and installations; content is implementation specific.
         * Format: Alphanumeric - {1,20}
         * Symbol Set: ALL
         * Remarks:
         * </pre>
         */
        val H_ADDITIONAL_INFO_1: String

        /**
         * <pre>
         * Unlisted Point Information
         * An alphanumeric text amplifier used to provide an up to a three-character letter field acronym to describe a point that is not already listed.
         * Format: Alphanumeric - {1,3}
         * Symbol Set: 25
         * Remarks: Only used with Action Points (General) control measure. SIDC 130100.
         * </pre>
         */
        val H1_ADDITIONAL_INFO_2: String

        /**
         * A text modifier for tactical graphics; content is
         * implementation specific.
         * CM: P,L,A,N,B/C,R/N
         * Length: 20
         * @deprecated 2525C
         */
        val H2_ADDITIONAL_INFO_3: String

        /**
         * <pre>
         * Evaluation Rating
         * An amplifier that consists of a one-letter reliability rating and a one-number credibility rating. (See ATP 2-33.4)
         * Format: Alphanumeric - {2,2} [X][#]
         * Symbol Set: 10, 15, 20,27, 40
         * Remarks:
         *
         * Reliability Ratings:
         * A-completely reliable
         * B-usually reliable
         * C-fairly reliable
         * D-not usually reliable
         * E-unreliable
         * F-reliability cannot be judged
         *
         * Credibility Ratings:
         * 1-confirmed by other sources
         * 2-probably true
         * 3-possibly true
         * 4-doubtfully true
         * 5-improbable
         * 6-truth cannot be judged
         * </pre>
         */
        val J_EVALUATION_RATING: String

        /**
         * <pre>
         * Effectiveness
         * An amplifier for units and installations that indicates unit effectiveness or installation capability.
         * Format: Alphanumeric - {2,3}
         * Symbol Set: 10, 15, 27
         * Remarks:
         * List of Values:
         * FO - Fully Operational
         * SO - Substantially operational
         * MO - Marginally operational
         * NO - Not operational
         * UNK - Unknown
         * </pre>
         */
        val K_COMBAT_EFFECTIVENESS: String

        /**
         * <pre>
         * Signature Equipment
         * An amplifier for hostile equipment; "!" indicates detectable electronic signatures.
         * Format: Alphanumeric - {1,1}
         * Symbol Set: 15
         * Remarks: The amplifier displayed is the exclamation mark "!".
         * </pre>
         */
        val L_SIGNATURE_EQUIP: String

        /**
         * <pre>
         * Higher Formation
         * An amplifier for units that indicates number or title of higher echelon command (corps are designated by Roman numerals).
         * Format: Alphanumeric - {1,21}
         * Symbol Set: 10
         * Remarks: The amplifier displayed is the exclamation mark "!".
         * </pre>
         */
        val M_HIGHER_FORMATION: String

        /**
         * <pre>
         * Hostile (Enemy)
         * An amplifier for equipment; letters "ENY" denote hostile symbols.
         * Format: Alphanumeric - {3,3}
         * Symbol Set: 15,25
         * Remarks: Determined by SIDC position 4.
         * Note: This amplifier must be used when displaying enemy/hostile control measures on monochromatic displays
         * </pre>
         */
        val N_HOSTILE: String

        /**
         * <pre>
         * IFF/SIF/AIS
         * An amplifier displaying IFF/SIF/AIS Identification modes and codes.
         * Format:
         * Symbol Set: 01, 10, 15, 27, 30, 35
         * Remarks: 'MODE' is not required when displaying.
         * </pre>
         */
        val P_IFF_SIF_AIS: String

        /**
         * <pre>
         * Direction of Movement Indicator
         * An amplifier consisting of a line with arrow that identifies the direction of movement or intended movement of an object (see 5.3.7.9 and figure 14).
         * Format: Graphic (Alphanumeric for exchange only)
         * Symbol Set: 10, 15, 20, 25, 27
         * Remarks:
         * Renderer Assumes a value in degrees with no text
         * MilStd:
         *
         * </pre>
         */
        val Q_DIRECTION_OF_MOVEMENT: String

        /**
         * <pre>
         * Mobility Indicator
         * An amplifier that depicts the mobility of an object not intrinsic to the entity itself (see 5.3.7.9, figure 14 and table IX).
         * Format: Graphic
         * Symbol Set: 10
         * Remarks: Determined by SIDC positions 9-10
         * </pre>
         */
        val R_MOBILITY_INDICATOR: String

        /**
         * <pre>
         * SIGINT Mobility Indicator
         * An amplifier that indicates the mobility of a SIGINT unit.
         * Format: Alphanumeric - {1,1}
         * Symbol Set: 50, 51, 52, 53, 54
         * Remarks:
         * List of Values:
         * M = Mobile,
         * S = Static
         * U = Uncertain.
         * </pre>
         */
        val R2_SIGNIT_MOBILITY_INDICATOR: String

        /**
         * <pre>
         * Headquarters Staff Indicator
         * An amplifier for units, installations and activities that identifies them as a headquarters (see figure 14 and figure 13).
         * Format: Graphic
         * Symbol Set: 10, 20, 40
         * Remarks: Determined by SIDC position 8.
         * </pre>
         */
        val S_HQ_STAFF_INDICATOR: String

        /**
         * <pre>
         * Offset Location Indicator
         * An amplifier used to indicate the offset or precise location of a single point symbol (see 5.3.7.5, 5.3.12, and figure 14).
         * Format: Graphic
         * Symbol Set: 10, 20, 25, 27, 40
         * Remarks: Determined by individual system implementations, not implemented by the renderer.
         * </pre>
         */
        val S2_OFFSET_INDICATOR: String

        /**
         * <pre>
         * Unique Designation
         * An amplifier that uniquely identifies a particular symbol or track number. Identifies acquisitions number when used with SIGINT symbology.
         * Format: Alphanumeric - {1,30}
         * Symbol Set: All
         * Remarks:
         * </pre>
         */
        val T_UNIQUE_DESIGNATION_1: String

        /**
         * <pre>
         * Lines - Unique Identifier or Primary Purpose
         * An amplifier that uniquely identifies a particular symbol or track number. Identifies acquisitions number when used with SIGINT symbology.
         * Format: Alphanumeric - {1,30}
         * Symbol Set: All
         * Remarks:
         * </pre>
         */
        val T1_UNIQUE_DESIGNATION_2: String

        /**
         * <pre>
         * Type
         * An amplifier for equipment that indicates types of equipment.
         * Format: Alphanumeric - {1,24}
         * Symbol Set: Not Installation(20), Activites(40), or CyberSpace(60)
         * Remarks:
         * Example:
         * AH-64 for Attack Helicopter
         * </pre>
         */
        val V_EQUIP_TYPE: String

        /**
         * <pre>
         * Date/Time Group (DTG) W
         * An amplifier for displaying a date-time group (DDHHMMSSZMONYYYY) or (DDHHMMZMMMYYYY) or "O/O" for On Order.
         * Field "W" is used to provide DTG or if used with field "W1" the start of a period of time.
         * Field "W1" is used to provide the end of a period of time.
         * Format: Alphanumeric - {3,16}
         * Symbol Set: 10, 15, 20, 25, 27, 40, 45
         * Remarks:
         * The date-time group is composed of a group of six numeric digits with a time zone suffix and the standardized three-letter abbreviation for the month followed by four digits representing the year.
         * The first pair of digits represents the day; the second pair, the hour; the third pair, the minutes. For automated systems, two digits may be added before the time zone suffix and after the minutes to designate seconds (see 5.3.7.8).
         * </pre>
         */
        val W_DTG_1: String

        /**
         * <pre>
         * Date/Time Group (DTG) W1
         * An amplifier for displaying a date-time group (DDHHMMSSZMONYYYY) or (DDHHMMZMMMYYYY) or "O/O" for On Order.
         * Field "W" is used to provide DTG or if used with field "W1" the start of a period of time.
         * Field "W1" is used to provide the end of a period of time.
         * Format: Alphanumeric - {3,16}
         * Symbol Set: 25
         * Remarks:
         * The date-time group is composed of a group of six numeric digits with a time zone suffix and the standardized three-letter abbreviation for the month followed by four digits representing the year.
         * The first pair of digits represents the day; the second pair, the hour; the third pair, the minutes. For automated systems, two digits may be added before the time zone suffix and after the minutes to designate seconds (see 5.3.7.8).
         * </pre>
         */
        val W1_DTG_2: String

        /**
         * <pre>
         * Altitude/Depth
         * An amplifier that displays either altitude, flight level, depth for submerged objects or height of equipment or structures on the ground, the minimum, maximum and/or specific altitude (in feet or meters in relation to a reference datum) or depth (for submerged objects in feet below sea level). See 5.3.7.6 for content.
         * Format:
         * Symbol Set: All but 40 & 60
         * Remarks:
         * SM = Statute Miles
         * DM = Data Miles
         * Notes:
         * The Renderer handles the whole value as a string for Single Point Icons.
         * For multipoints, it expects just a number and an accompanying attribute {@link MilStdAttributes.AltitudeUnits}
         * Default behavior assumes feet.
         * </pre>
         */
        val X_ALTITUDE_DEPTH: String

        /**
         * <pre>
         * Location
         * An amplifier that displays a symbol's location in degrees, minutes and decimal minutes (or in MGRS, GARS, or other applicable display formats).
         * Format: Alphanumeric - {3,16}
         * Symbol Set: 10, 15, 20, 25, 27, 30, 40
         * Remarks: Exchange format is implementation specific.
         * </pre>
         */
        val Y_LOCATION: String

        /**
         * <pre>
         * Speed
         * An amplifier that displays velocity (see 5.3.7.7).
         * Format: Alphanumeric - {5,9} [#####] [XXX]
         * Symbol Set: NOT 20, 35, 40, 60
         * Remarks:
         * Two-part composite field.
         * Where # is the numeric value [1-999999999], and XXX is the unit of measure (KPH, KPS, MPH, NMH, KTS).
         * Note: There should be a space between the numeric and the unit of measure values.
         * </pre>
         */
        val Z_SPEED: String

        /**
         * <pre>
         * Special C2 Headquarters
         * A amplifier that is contained inside the frame in place of the main icon and contains the name of the special C2 Headquarters.
         * Format: Alphanumeric - {1,9}
         * Symbol Set: 10
         * Remarks:
         * Examples: Named command such as SHAPE, PACOM, and joint, multinational, or coalition commands such as CJTF, JTF, or MJTF.
         * </pre>
         */
        val AA_SPECIAL_C2_HQ: String

        /**
         * <pre>
         * Feint/Dummy indicator
         * An amplifier that identifies an offensive or defensive unit, intended to draw the enemy's attention away from the area of the main attack.
         * Format: Graphic
         * Symbol Set: 10, 15, 20, 25
         * Remarks: Determined by SIDC position 8.
         * </pre>
         */
        val AB_FEINT_DUMMY_INDICATOR: String

        /**
         * <pre>
         * Platform Type
         * An amplifier that identifies the electronic identification for a pulsed or non-pulsed electromagnetic emission.
         * Format: Alphanumeric - {5,5}
         * Symbol Set: 10, 15
         * Remarks:
         * List of Values:
         * ELNOT = Electronic intelligence notation
         * CENOT = Communications intelligence notation
         * </pre>
         */
        val AD_PLATFORM_TYPE: String

        /**
         * <pre>
         * Platform Type
         * An amplifier that identifies equipment teardown time in minutes.
         * Format: Numeric  {1,3}
         * Symbol Set: 10(2525E), 15
         * Remarks:
         * </pre>
         */
        val AE_EQUIPMENT_TEARDOWN_TIME: String

        /**
         * <pre>
         * Common Identifier
         * An amplifier to provide a common name used to identify an entity.
         * Format: Alphanumeric - {1,12}
         * Symbol Set: 10(2525E), 15, 27
         * Remarks: Example: "Hawk" for Hawk SAM system.
         * </pre>
         */
        val AF_COMMON_IDENTIFIER: String

        /**
         * <pre>
         * Auxiliary Equipment Indicator
         * An amplifier for equipment that indicates the presence of a towed sonar array (see 5.3.7.11, figure 14 and table IX).
         * Format: Graphic
         * Symbol Set: 15
         * Remarks: Determined by SIDC positions 9-10.
         * </pre>
         */
        val AG_AUX_EQUIP_INDICATOR: String

        /**
         * <pre>
         * Area of Uncertainty
         * An amplifier that indicates the area where an object is most likely to be, based on the object's last report and
         * the reporting accuracy of the sensor that detected the object (see 5.3.7.13.1 and figure 18.
         * Format: Graphic (Alphanumeric for exchange only)
         * Symbol Set: 01, 05, 10, 15, 20, 25, 27, 30, 35, 40
         * Remarks:
         * The amplifier can be displayed as an ellipse, a bearing box, or a line of bearing, depending on the report received for the object.
         * Notes: Not implemented by the renderer
         * </pre>
         */
        val AH_AREA_OF_UNCERTAINTY: String

        /**
         * <pre>
         * Dead Reckoning Trailer
         * An amplifier that identifies where an object should be located at present, given its last reported course and speed (see 5.3.7.13.2).
         * Format: Graphic
         * Symbol Set: 01, 05, 10, 15, 20, 25, 27, 30, 35, 40
         * Remarks:
         * Locally derived information. This datum is not exchanged.
         * Notes: Not implemented by the renderer
         * </pre>
         */
        val AI_DEAD_RECKONING_TRAILER: String

        /**
         * <pre>
         * Speed Leader
         * An amplifier that depicts the speed and direction of movement of an object (see 5.3.7.13.3 and figure 18).
         * Format: Graphic
         * Symbol Set: 10, 15, 30, 35
         * Remarks:
         * Land units and equipment use the Direction of Movement and Speed amplifiers for this information.
         * Notes: Not implemented by the renderer
         * </pre>
         */
        val AJ_SPEED_LEADER: String

        /**
         * <pre>
         * Pairing Line
         * An amplifier that connects two objects and is updated dynamically as the positions of the two objects change (see 5.3.7.13.4 and figure 18).
         * Format: Graphic
         * Symbol Set: NA
         * Remarks:
         * Notes: Not implemented by the renderer
         * </pre>
         */
        val AK_PAIRING_LINE: String

        /**
         * <pre>
         * Operational Condition
         * An amplifier that indicates operational condition or capacity.
         * Format: Graphic
         * Symbol Set: 01, 05,10, 15, 20, 30, 35
         * Remarks: Determined by SIDC position 7.
         * </pre>
         */
        val AL_OPERATIONAL_CONDITION: String

        /**
         * <pre>
         * Distance
         * An amplifier that displays a minimum, maximum, or a specific distance (range, radius, width, length, etc.), in meters.
         * Format: Alphanumeric - {3,9} [#] [X]
         * Symbol Set: 25
         * Remarks:
         * "#" is the value (range 0-99999)
         * XXX is the distance unit.
         * There should be a space between the integer and the unit of measure values.
         * Where more than one distance is specified the AM amplifier will be suffixed with a numeric entry, e.g. AM1, AM2.
         * Note:
         * Renderer expects just a number or a comma delimited string of numbers and an accompanying attribute {@link MilStdAttributes.DistanceUnits}
         * Default behavior assumes meters.
         * </pre>
         */
        val AM_DISTANCE: String

        /**
         * <pre>
         * Azimuth
         * An amplifier that displays an angle measured from true north to any other line in degrees.
         * Format: Alphanumeric - {7,8} [#####] [XXX]
         * Symbol Set: 25
         * Remarks:
         * For Degrees entries.
         * XXX DGT, where XXX is degrees from 000-359 and DGT is referenced to TRUE North.
         * For Mils entries.
         * XXXX MGT, where XXXX is MILS from 0000-6399 and MGT is referenced to TRUE North.
         * Where more than one angle is specified the AN amplifier will be suffixed with a numeric entry, e.g. AN1, AN2.
         * Note:
         * Renderer expects just a number or a comma delimited string of numbers
         * </pre>
         */
        val AN_AZIMUTH: String

        /**
         * Engagement Bar
         * A graphic amplifier placed immediately atop the symbol. May denote:
         * A) local/remote engagement status - 'R' for remote, 'B' for mix of local/remote, none for local
         * B) engagement status
         * C) weapon type.
         *
         * Format:
         * Composite list of values
         * Alphanumeric - {6,10}
         * A:BBB-CC
         * Symbol Set: 01, 05, 10, 30, 35
         * Remarks: See 5.3.7.15.3 for explanation of engagement bar structure and codes.
         * A - Type of Engagement
         * BBB - Engagement Stage
         * CC - Type of Weapon Assignment
         */
        val AO_ENGAGEMENT_BAR: String

        /**
         * <pre>
         * Target Number
         * An amplifier used in Fire Support operations to uniquely designate targets in accordance with STANAG 2934.
         * Format: Alphanumeric - {6,6} [XX][####]
         * Symbol Set: 25
         * Remarks:
         * Two-part composite field.
         * Where positions 1-2 are text, and positions 3-6 are numeric.
         * </pre>
         */
        val AP_TARGET_NUMBER: String

        /**
         * <pre>
         * Target Number Extension
         * An amplifier used to identify a target number extension which is a sequentially assigned number identifying the individual elements in a target (MIL-STD-6017),
         * Format: Numeric  {2,3} [-##]
         * Symbol Set: 25
         * Remarks:
         * Position 1 is a dash (-) and positions 2-3 are numbers, from 1 through 15.
         * It is applicable only to the "Point or Single Target" symbol.
         * It is conditional upon the presence of the Target Number amplifier and is visually displayed appended to the Target Number amplifier.
         * </pre>
         */
        val AP1_TARGET_NUMBER_EXTENSION: String

        /**
         * <pre>
         * Guarded Unit
         * An amplifier used during ballistic missile defense. Some tracks are designated as guarded by a particular unit.
         * Format: Alphanumeric - {6,6} [XX]
         * Symbol Set: 10(2525E), 15, 20(2525E), 30
         * Remarks:
         * Single value:
         * BG - Guarded Unit
         * </pre>
         */
        val AQ_GUARDED_UNIT: String

        /**
         * <pre>
         * Special Designator
         * An amplifier that identifies special track designators.
         * Format: Alphanumeric - {3,3}
         * Symbol Set: 10, 30, 35
         * Remarks:
         * List of values:
         * NRT - Non-Real Time.
         * SIG - Tactically Significant Tracks.
         * </pre>
         */
        val AR_SPECIAL_DESIGNATOR: String

        /**
         * <pre>
         * Country
         * A three-letter code that indicates the country of origin of the organization (US systems shall use GENC).
         * Format: Alphanumeric - {3,3}
         * Symbol Set: All
         * Remarks: Determined by SIDC positions 28-30.
         * </pre>
         */
        val AS_COUNTRY: String

        /**
         * <pre>
         * Capacity of Installation
         * Capacity of installation displayed.
         * Format: Alphanumeric - {1,19} [#########] [XXXXXXXXXX]
         * Symbol Set: 2525E addition, not currently defined.  Probably 20
         * Remarks:
         * Two-part composite field.
         * Comprised of:
         * Quantity 0-99999999 followed by the unit of measure.
         * e.g. 400 Beds
         * </pre>
         */
        val AT_CAPACITY_OF_INSTALLATION: String

        /**
         * <pre>
         * Leadership
         * Identifies Leadership (ONLY IN DISMOUNTED INDIVIDUAL)
         * Format: Graphic
         * Symbol Set: 27(2525E)
         * Remarks: Determined by SIDC positions 9-10.
         * </pre>
         */
        val AV_LEADERSHIP: String

        /**
         * <pre>
         * Headquarters Element
         * An amplifier that indicates what type of element of a headquarters is being represented, such as TOC, MAIN2.
         * Format: Alphanumeric {0,8}
         * Symbol Set: 10(2525E)
         * Remarks: Location currently undefined
         * </pre>
         */
        val AW_HEADQUARTERS_ELEMENT: String

        /**
         * <pre>
         * Installation Composition
         * Indicates the component type of the installation
         * Format: Alphanumeric {3,7}
         * Symbol Set: 20(2525E)
         * Remarks: Location currently undefined
         * List of Values:
         * DEVELOP - Development.
         * RSRCH - Research.
         * PROD - Production.
         * SVC - Service.
         * STORE - Storage.
         * UTIL - Utility.
         * </pre>
         */
        val AX_INSTALLATION_COMPOSITION: String

        /**
         * <pre>
         * Network Identifier
         * Indicates the network the entity has privileges within.
         * Format: Alphanumeric
         * Symbol Set: undefined
         * Remarks:
         * The colour of the graphic shall be assignable by the operator.
         * Notes: undefined
         * </pre>
         */
        val AY_NETWORK_IDENTIFIER: String

        /**
         * Returns an Arraylist of the all the modifiers that appear as labels and are not
         * derived from the symbol code or are external to symbol data like offset indicator.
         * Also includes modifiers that control the shape of a symbol like AM &amp; AN.
         * @return Array<string>
         */
        fun GetModifierList(): Array<String>

        /**
         * Returns an ArrayList of the modifier constants that are determined by the symbol code
         * and therefore don't need their values to be manually typed or selected.
         * (Based on the comments in GetModifierList, GetUnitModifierList, and GetControlMeasureModifierList.)
         * @return Array<string>
         */
        fun GetSymbolCodeModifiersList(): Array<String>

        /**
         * Returns an Arraylist of the modifier names for units
         * @return Array<string>
         */
        fun GetUnitModifierList(): Array<String>

        /**
         * Returns an Arraylist of the modifiers for Control Measures
         * @return Array<string>
         */
        fun GetControlMeasureModifierList(): Array<String>

        /**
         *
         * @param modifier like Modifiers.C_QUANTITY
         * @return modifier name based on modifier constants
         */
        fun getModifierName(modifier: String): String

        /**
         *
         * @param modifier like Modifiers.C_QUANTITY
         * @return modifier name based on modifier constants
         */
        fun getModifierLetterCode(modifier: String): String

        /**
         * Returns the description for a modifier constant
         * @param modifier {@link Modifiers}
         * @return
         */
        fun getModifierDescription(modifier: String): String

        /**
         * go from "T" or "T1" to integer constant values 9 and 10
         * @param modLetter
         * @return {@link Modifiers}
         */
        fun getModifierKey(modLetter: String): String?
    }
}

/**
 * Draw Rules for Control Measures
 *
 */
external class DrawRules {

    companion object {
        /**
         * Usually an entry in the MilStd that is just a category containing other symbols
         * and not something that gets drawn itself.
         */
        val DONOTDRAW: Number

        /**
         * Anchor Points: This symbol requires at least three anchor points to
         * define the boundary of the area. Add as many points as necessary to
         * accurately reflect the areas size and shape.
         *
         * Size/Shape: Determined by the anchor points. The information fields
         * should be moveable and scalable as a block within the area.
         *
         * Orientation: Not applicable.
         */
        val AREA1: Number

        /**
         * Anchor Points: This symbol requires at least three anchor points to
         * define the boundary of the area. Add as many points as necessary to
         * accurately reflect the areas size and shape. The LAA point symbol
         * requires one anchor point and is connected to the area symbol with a
         * straight line.
         *
         * Size/Shape: Determined by the anchor points. The information fields
         * should be moveable and scalable as a block within the area.
         *
         * Orientation: Not applicable.
         */
        val AREA2: Number

        /**
         * Anchor Points: This symbol requires at least three anchor points to
         * define the boundary of the area. Add as many points as necessary to
         * accurately reflect the areas size and shape.
         *
         * Size/Shape: Determined by the anchor points.
         *
         * Orientation: The side opposite Field B (Echelon) faces toward the
         * hostile force.
         */
        val AREA3: Number

        /**
         * Anchor Points: This symbol requires at least three anchor points to
         * define the boundary of the area. Add as many points as necessary to
         * accurately reflect the areas size and shape.
         *
         * Size/Shape: Determined by the anchor points. The information fields
         * should be moveable and scalable as a block within the area. The default
         * tic length should be the same as the text height of the echelon
         * field (B). Spacing between the tics should also be the height of B.
         * Users should be provided a facility to allow them to manually alter the
         * height of B, which in turn should affect the tic length and spacing
         * accordingly.
         *
         * Orientation: Not applicable.
         */
        val AREA4: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the endpoints of the semicircle's opening. Point 3 defines the end
         * of the arrow.
         *
         * Size/Shape: Points 1 and 2 determine the diameter of the semicircle and
         * point 3 determines the length of the arrow. The tip of the arrowhead will
         * be at the center point of the semicircle's diameter and will project
         * perpendicularly from the line between points 1 and 2. The default tic
         * length should be the same as the text height of the echelon field (B).
         * Spacing between the tics should also be the height of B. Users should be
         * provided a facility to allow them to manually alter the height of B,
         * which in turn should affect the tic length and spacing accordingly.
         *
         * Orientation: The opening typically faces enemy forces.
         */
        val AREA5: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Point 1 defines
         * the center point of the symbol and point 2 defines the symbols start
         * point and radius.
         *
         * Size/Shape: Points 1 and 2 will determine a radius that is long enough
         * for the graphic to encompass the feature(s) being retained. The opening
         * will be a 30-degree arc of the circle. The default tic length should be
         * the same as the text height of the echelon field (R). Spacing between
         * the tics should also be the height of R. Users should be provided a
         * facility to allow them to manually alter the height of R, which in turn
         * should affect the tic length and spacing accordingly.
         *
         * Orientation: The opening will be on the friendly side of the symbol.
         */
        val AREA6: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Point 1 is the
         * tip of the arrowhead. Points 2 and 3 define the endpoints of the straight
         * line on the back side of the symbol.
         *
         * Size/Shape: Points 2 and 3 determine the length of the straight line on
         * the back side of the symbol. The rear of the arrowhead line shall connect
         * to the midpoint of the line between points 2 and 3. The arrowhead line shall be perpendicular to the line formed by points 2 and 3.
         *
         * Orientation: Orientation is determined by the anchor points. The back
         * side of the symbol encompasses the firing position, while the arrowhead
         * typically points at the target.
         */
        val AREA7: Number

        /**
         * Anchor Points: This symbol requires four anchor points. Points 1 and 2
         * define the endpoints of the straight line on the back side of the symbol.
         * Points 3 and 4 define the tips of the arrowheads.
         *
         * Size/Shape: Points 1 and 2 determine the length of the straight line on
         * the back side of the symbol. The rear of the arrows should connect to
         * points 1 and 2.
         *
         * Orientation: Orientation is determined by the anchor points. The back
         * side of the symbol encompasses the firing position, while the arrowheads
         * typically indicate the left and right limits of coverage that the firing
         * position is meant to support.
         */
        val AREA8: Number

        /**
         * Anchor Points: This symbol requires at least three anchor points to
         * define the boundary of the area. Add as many points as necessary to
         * accurately reflect the areas size and shape.
         *
         * Size/Shape: Determined by the anchor points.
         *
         * Orientation: Not applicable. The area will encompass two or more fire
         * support symbols (point/single target, nuclear target, circular target,
         * rectangular target, or area target).
         * The naming convention determines whether the area describes a series or
         * group of targets.
         *
         */
        val AREA9: Number

        /**
         * Anchor Points: This symbol requires a minimum of three (3) and a maximum
         * of six (6) anchor points to define the boundary of the area. The anchor
         * points shall be sequentially numbered, in increments of one (1),
         * beginning with point one (1).
         *
         * Size/Shape: Determined by the anchor points. The information fields
         * should be moveable and scalable within the area.
         *
         * Orientation: Not applicable.
         */
        val AREA10: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the endpoints of the symbols vertical line. Point 3 defines the
         * endpoint of the symbols horizontal line.
         *
         * Size/Shape: Points 1 and 2 determine the length of the vertical line.
         * The length of the horizontal line is determined by plotting point 3 on a
         * plane extending perpendicularly from the midpoint of the vertical line.
         *
         * Orientation: The head of the "T" typically faces enemy forces.
         */
        val AREA11: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the end points of the symbols vertical line. Point 3 defines the
         * tip of the longest arrow.
         *
         * Size/Shape: Points 1 and 2 determine the height of the symbol and point
         * 3 determines its length. The spacing between the symbols arrows will
         * stay proportional to the symbols vertical line. The length of the short
         * arrows will remain in proportion to the length of the longest arrow.
         *
         * Orientation: The arrows point away from enemy forces.
         */
        val AREA12: Number

        /**
         * Anchor Points: This symbol requires at least two anchor points. Points
         * 1 and 2 define the corners of the symbol.
         *
         * Size/Shape: Points 1 and 2 determine the length of the straight line.
         * The radius of the semicircle is  the length of the straight line.
         *
         * Orientation: Not applicable.
         */
        val AREA13: Number

        /**
         * Anchor Points: This symbol requires three anchor points. The center point
         * defines the center of the symbol. Points 1 and 2 define the radii of
         * circles 1 and 2.
         *
         * Size/Shape: As defined by the operator.
         *
         * Orientation: The center point is typically centered over Ground Zero (GZ)
         * or Designated Ground Zero (DGZ).
         */
        val AREA14: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Point 1 defines
         * the center point of the symbol and point 2 defines the symbols start
         * point and radius.
         *
         * Size/Shape: The radius will be long enough for the symbol to encompass
         * the UEI(s) or feature(s) being isolated. The opening will be a 30 degree
         * arc of the circle.
         *
         * Orientation: The opening will be on the friendly side of the symbol.
         */
        val AREA15: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Point 1 defines
         * the center point of the symbol and point 2 defines the symbols start
         * point and radius.
         *
         * Size/Shape: Points 1 and 2 will determine a radius that is long enough
         * for the symbol to encompass the feature(s) being occupied. The opening
         * will be a 30-degree arc of the circle.
         *
         * Orientation: The opening will be on the friendly side of the
         * control measure.
         */
        val AREA16: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the endpoints of the symbols vertical line. Point 3 defines the
         * rear of the symbol.
         *
         * Size/Shape: Points 1 and 2 determine the height of the symbol and
         * point 3 determines its length. The arrow will project perpendicularly
         * from the midpoint of the vertical line.
         *
         * Orientation: The arrow points toward enemy forces.
         */
        val AREA17: Number

        /**
         * Anchor Points: This symbol requires four anchor points. Point 1 defines
         * the tip of the first arrowhead. Point 2 defines the end of the straight
         * line portion of the first arrow. Point 3 defines the tip of the second
         * arrowhead. Point 4 defines the end of the second arrow.
         *
         * Size/Shape: Points 1 and 2 and points 3 and 4 determine the length of
         * each arrow. Points 2 and 3 shall be connected by a smooth, curved line.
         *
         * Orientation: Determined by the anchor points. The unit being relieved is
         * typically located at the base of the curve and the unit performing the
         * relief is typically located at the end of the symbol. The arrowhead
         * typically points to the location the relieved unit should move to.
         */
        val AREA18: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Point 1 defines
         * the center point of the symbol and point 2 defines the symbols start
         * point and radius.
         *
         * Size/Shape: Points 1 and 2 will determine a radius that is long enough
         * for the symbol to encompass the feature(s) being secured. The opening
         * will be a 30-degree arc of the circle.
         *
         * Orientation: The opening will be on the friendly side of the symbol.
         */
        val AREA19: Number

        /**
         * Anchor Points: This symbol requires at least three anchor points to
         * define the boundary of the area. Add as many points as necessary to
         * accurately reflect the areas size and shape.
         *
         * Size/Shape: Determined by the anchor points.
         *
         * Orientation: Not applicable.
         */
        val AREA20: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Point 1 defines
         * the vertex of the symbol. Points 2 and 3 define the tips of the
         * arrowheads.
         *
         * Size/Shape: Points 1 and 2 and points 1 and 3 determine the length of the
         * arrows. The length and orientation of the arrows can vary independently.
         *
         * Orientation: Orientation is determined by the anchor points.
         * The arrowheads may touch other symbols that define the limits of the
         * task. The tactical symbol indicator is centered over point 1.
         */
        val AREA21: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The center point
         * defines the center of the symbol.
         *
         * Size/Shape: Static.
         *
         * Orientation: The symbol is typically centered over the desired location.
         */
        val AREA22: Number

        /**
         * Anchor Points: This symbol requires at least three anchor points to
         * define the boundary of the area.
         *
         * Size/Shape: Determined by the anchor points
         *
         * Orientation: Not applicable.
         */
        val AREA23: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the endpoints of the symbols vertical line. Point 3 defines the
         * endpoint of the symbols horizontal line.
         *
         * Size/Shape: Points 1 and 2 determine the length of the vertical line.
         * Points 2 and 3 determine the length of the horizontal line, which will
         * project perpendicularly from the midpoint of the vertical line.
         *
         * Orientation: The head of the "T" typically faces enemy forces.
         */
        val AREA24: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the end points of the symbols vertical line. Point 3 defines the
         * tip of the longest arrow.
         *
         * Size/Shape: Points 1 and 2 determine the height of the symbol and
         * point 3 determines its length. The spacing between the symbols arrows
         * will stay proportional to the symbols vertical line. The length of the
         * short arrows will remain in proportion to the length of the longest
         * arrow. The arrows are perpendicular to the baseline (vertical line) and
         * parallel to each other.
         *
         * Orientation: The arrows typically point toward enemy forces.
         */
        val AREA25: Number

        /**
         * Anchor Points: This symbol requires a minimum of 6 anchor points. Add as
         * many pairs of points as needed to accurately define the areas. The number
         * of points shall always be an even number, with an equal number of points
         * for both polygons. Points 1 through N/2 define the inner safe zone
         * (zone 1). Points N/2 +1 though point N defines the outer zone (zone 2).
         *
         * Size/Shape: Determined by the anchor points.
         *
         * Orientation: The symbol will typically be oriented upright.
         */
        val AREA26: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The anchor point
         * defines/is the tip of the inverted cone.
         *
         * Size/Shape: Static.
         *
         * Orientation: The symbol will typically be oriented upright.
         */
        val POINT1: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The center point
         * defines/is the center of the symbol.
         *
         * Size/Shape: Static.
         *
         * Orientation: The symbol is typically centered over the desired location.
         */
        val POINT2: Number

        /**
         * Anchor Points: This symbol requires one anchor point.
         * The center point defines the center of the symbol.
         *
         * Size/Shape: Static. Maneuver area symbol shall be drawn with a black
         * border. Maneuver areas may be either unfilled or filled with
         * performance-contoured color options
         *
         * Orientation: The symbol is typically centered over the desired location.
         */
        val POINT3: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The point defines
         * the bottom of the central vertical line in the symbol where the curved
         * and vertical lines meet.
         *
         * Size/Shape: Static.
         *
         * Orientation: The symbol will typically be oriented upright (as shown in the template and example).
         */
        val POINT4: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The point defines
         * the point where all the lines meet.
         *
         * Size/Shape: Static.
         *
         * Orientation: The symbol will typically be oriented upright (as shown in
         * the example).
         */
        val POINT5: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The anchor point
         * defines/is the center of the bottom of the control measure symbol as
         * shown in the template and example.
         *
         * Size/Shape: Static.
         *
         * Orientation: The symbol will typically be oriented upright.
         */
        val POINT6: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The anchor point
         * defines the midpoint of the symbol's base.
         *
         * Size/Shape: Static.
         *
         * Orientation: The symbol will typically be oriented upright (as shown in
         * the template and example).
         */
        val POINT7: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The center point
         * defines the center of the symbol.
         *
         * Size/Shape: Static. The symbol's corners form a 70- degree angle.
         *
         * Orientation: The symbol is typically centered over the desired location.
         * A user can use this symbol to define a new type of point if the selection
         * that follows is not sufficient.
         */
        val POINT8: Number

        /**
         * Anchor Points: This symbol requires one anchor (center) point. The point
         * defines the center of the symbol.
         *
         * Size/Shape: Static. The symbol's height should be 2x the symbol's width.
         *
         * Orientation: The symbol's center point is typically centered over the
         * desired location. The symbol shall be oriented upright, as shown in the
         * examples.
         */
        val POINT9: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The point defines
         * the center of the circle. (Sonobuoy)
         *
         * Size/Shape: Static. The diameter of the circle should be 1/2 the height
         * of the symbol.
         *
         * Orientation: The symbol's center point is typically centered over the
         * desired location. The symbol will be oriented upright, as shown in the
         * example.
         */
        val POINT10: Number

        /**
         * Anchor Points: This symbol requires one center point. The point defines
         * the center of the symbol.
         *
         * Size/Shape: Static. Length is 2x the size of height.
         *
         * Orientation: The symbol is centered over the desired location. The symbol
         * shall be oriented upright, as shown in the example.
         */
        val POINT11: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the tips of the arrowheads and point 3 defines the rear of the
         * symbol.
         *
         * Size/Shape: Points 1 and 2 determine the symbol's height and point 3
         * determines its length. The vertical line at the rear of the symbol shall
         * be the same length as the opening, and shall be perpendicular to the
         * parallel lines formed with the rear of symbol vertical line and the lines
         * ending with points 1 and 2.
         *
         * Orientation: The opening typically faces the applicable obstacle.
         */
        val POINT12: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The center point
         * defines the center of the circle.
         *
         * Size/Shape: Static.
         *
         * Orientation: The symbol is typically centered over the desired location.
         */
        val POINT13: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The center point
         * defines the center of the symbol.
         *
         * Size/Shape: There should be 45 degrees of angular separation between the
         * two arrows.
         *
         * Orientation: The symbol is typically centered over the desired location.
         */
        val POINT14: Number

        /**
         * Anchor Points: This symbol requires one anchor point. The anchor point
         * defines "nose" of the symbol.
         *
         * Size/Shape: Static.
         *
         * Orientation: The symbol is typically centered over the desired location.
         */
        val POINT15: Number

        /**
         * Anchor Points: This symbol requires one anchor point; the point defines
         * the circle at the base of the tower.
         *
         * Size/Shape: The symbol is a high-angle cone.
         *
         * Orientation: The symbol will remain upright.
         */
        val POINT16: Number

        /**
         * Anchor Points: This symbol requires one anchor point. This anchor point
         * represents the center of the rectangle and, therefore, the geographic
         * location of that rectangle.
         *
         * Size/Shape: The size and shape of this symbol is determined by three
         * additional numeric values; A length (AM1), a width (AM2), and a
         * rotation angle. The length and width should be expressed in the
         * appropriate map distance units. The length is aligned with the axis of
         * rotation. The width is aligned perpendicular to the axis of rotation.
         *
         * Orientation: The orientation of this symbol is determined by the
         * rotation angle provided, where 0 degrees is North and a positive
         * rotation angle rotates the rectangle in a clockwise direction.
         */
        val POINT17: Number

        /**
         * Anchor Points: This symbol requires one anchor point that defines the
         * axis of angular rotation.
         *
         * Size/Shape: The size and shape of this symbol is determined by additional
         * numeric values; A search axis azimuth, a start range, a stop range and a
         * stop relative bearing. The stop relative bearing is an equal angle either
         * side of the search axis. The start and stop range should be expressed in
         * the appropriate map distance units. Field T should be positioned in the
         * center of the search area aligned with the search axis.
         *
         * Orientation: The orientation of this symbol is determined by the search
         * axis azimuth provided.
         */
        val POINT18: Number

        /**
         * Anchor Points: This symbol requires at least two anchor points, points 1
         * and 2, to define the line. Additional points can be defined to extend the
         * line.
         *
         * Size/Shape: The first and last anchor points determine the length of the
         * line.
         *
         * Orientation: Orientation is determined by the order in which the anchor points are entered.
         */
        val LINE1: Number

        /**
         * Anchor Points: This symbol requires at least two anchor points, points
         * 1 and 2, to define the line. Additional points can be defined to extend
         * the line.
         *
         * Size/Shape: The first and last anchor points determine the length of the line.
         * The end-of line information will typically be posted at the ends of the line
         * as it is displayed on the screen.
         *
         * Orientation: Orientation is determined by the order in which the anchor points
         * are entered.
         */
        val LINE2: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Point 1 defines
         * the vertex of the symbol. Points 2 and 3 define the tips of the arrowheads.
         *
         * Size/Shape: The length and orientation of the arrows can vary
         * independently.
         *
         * Orientation: Orientation is determined by the anchor points. The
         * arrowheads may touch other symbols that define the limits of the task.
         * The top of the tactical symbol indicator may touch point 1
         */
        val LINE3: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Points 1 and 2
         * define the corner points of the symbol.
         *
         * Size/Shape: The symbol varies only in length.
         *
         * Orientation: Orientation is determined by the anchor points.
         */
        val LINE4: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Points 1 and 2
         * define the endpoints of the symbol.
         *
         * Size/Shape: The symbol varies only in length.
         *
         * Orientation: One point defines the origin from which the bearing is being
         * taken and the other point defines the location or direction from which a
         * contact is made.
         */
        val LINE5: Number

        /**
         * Anchor Points: This symbol requires 3 anchor points. Point 1 defines the
         * vertex of the symbol and points 2 and 3 define its endpoints.
         *
         * Size/Shape: Points 1, 2 and 3 determine the length of the lines
         * connecting them. The line defined by points 1 and 2 is typically the same
         * length as the line between points 2 and 3.
         *
         * Orientation: Orientation is determined by the anchor points
         */
        val LINE6: Number

        /**
         * Anchor Points: This symbol requires at least two anchor points, points
         * 1 and 2, to define the line. Additional points can be defined to extend
         * the line.
         *
         * Size/Shape: The first and last anchor points determine the length of the
         * line. The line information will be posted once at the center of the line
         * as it is displayed on the screen.
         *
         * Orientation: Orientation is determined by the order in which the anchor
         * points are entered.
         */
        val LINE7: Number

        /**
         * Anchor Points: This symbol requires a minimum of two (2) anchor points.
         * Up to 298 additional points can be added to extend the line. The first
         * point (point 1) defines the start point. The last point defines the
         * endpoint. The points are numbered sequentially beginning with point one (1), in increments of one.
         *
         * Size/Shape: The anchor points define the size and shape.
         *
         * Orientation: The orientation is determined by the anchor points.
         */
        val LINE8: Number

        /**
         * Anchor Points: This symbol requires 2 anchor points. Point 1 defines the
         * tip of the arrowhead and point 2 defines the rear of the symbol.
         *
         * Size/Shape: Points 1 and 2 determine the length of the symbol, which
         * varies only in length.
         *
         * Orientation: The orientation is determined by the anchor points.
         */
        val LINE9: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Point 1 defines
         * the tip of the arrowhead and point 2 defines the rear of the symbol.
         * Point 3 defines the 90 degree arc.
         *
         * Size/Shape: Points 1 and 2 are connected by a 90 degree arc. Point 3
         * indicates on which side of the line the arc is placed.
         *
         * Orientation: The rear of the symbol identifies the enemys location and
         * the arrow points in the direction the obstacle should force the enemy to
         * turn.
         */
        val LINE10: Number

        /**
         * Anchor Points: This symbol requires four points. Points 1 and 2 define
         * one side of the gap and points 3 and 4 define the opposite side of the
         * gap.
         *
         * Size/Shape. Determined by the anchor points.
         *
         * Orientation: Not applicable.
         */
        val LINE11: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the endpoints of the symbol and point 3 defines the location of
         * one side of the symbol.
         *
         * Size/Shape: Points 1 and 2 determine the centerline of the symbol and
         * point 3 determines its width.
         *
         * Orientation: Orientation is determined by the anchor points.
         */
        val LINE12: Number

        /**
         * Anchor Points: This symbol requires at least two anchor points, points 1
         * and 2, to define the line. Additional points can be defined to extend the
         * line.
         *
         * Size/Shape: The first and last anchor points determine the length of the
         * line. The size of the tooth does not change.
         *
         * Orientation: Orientation is determined by the anchor points.
         */
        val LINE13: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Points 1 and 2
         * define the tips of the arrowheads.
         *
         * Size/Shape: Points 1 and 2 determine the length of the symbol, which
         * varies only in length. The lines of the arrowhead will form an acute
         * angle.
         *
         * Orientation: Orientation is determined by the anchor points.
         */
        val LINE14: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Points 1 and 2
         * define the length and orientation of the straight line (trip wire)
         * portion of the symbol.
         *
         * Size/Shape: Points 1 and 2 determine the length and orientation of the
         * line drawn from the physical mine to the end of the trip wire. The
         * distance between the line connecting points 1 and 2 is the length of
         * the trip wire connected to the mine.
         *
         * Orientation: Orientation is determined by the anchor points.
         */
        val LINE15: Number

        /**
         * Anchor Points: This symbol requires four points. Points 1 and 2 define
         * one side of the assault crossing site and points 3 and 4 define the
         * opposite side of the assault crossing site.
         *
         * Size/Shape: Determined by the anchor points.
         *
         * Orientation: Not applicable.
         */
        val LINE16: Number

        /**
         * Anchor Points. This symbol requires three anchor points. Points 1 and 2
         * define the endpoints of the first line. Point 3 defines the location of
         * the parallel line.
         *
         * Size/Shape: Points 1 and 2 determine the length of the symbol. Point 3
         * determines its width.
         *
         * Orientation: Orientation is determined by the anchor points.
         */
        val LINE17: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Points 1 and two
         * define the tips of the arrowheads.
         *
         * Size/Shape: Points 1 and 2 determine the length of the symbol, which
         * varies only in length. The arrowheads will be filled-in versions of a
         * common arrowhead.
         *
         * Orientation: Orientation is determined by the anchor points.
         */
        val LINE18: Number

        /**
         * Anchor Points: This symbol requires two anchor points. Points 1 and two
         * define the corners on the front of the symbol.
         *
         * Size/Shape: Points 1 and 2 determine the length of the symbol, which
         * varies only in length.
         *
         * Orientation: Orientation is determined by the anchor points
         */
        val LINE19: Number

        /**
         * Anchor Points: This graphic requires two anchor points. Point 1 defines
         * the tip of the arrowhead, and point 2 defines the rear of the graphic.
         *
         * Size/Shape: Points 1 and 2 determine the length of the graphic, which
         * varies only in length.
         *
         * Orientation: The arrow points to the location where the convoy has halted.
         */
        val LINE20: Number

        /**
         * Anchor Points: This symbol requires at least two anchor points to define
         * the line. Additional points can be defined to extend and shape the line.
         *
         * Size/Shape: The first and last anchor points determine the length of the
         * line. The line segment between each pair of anchor points will repeat all
         * information associated with the line segment.
         *
         * Orientation: Orientation is determined by the anchor points.
         */
        val LINE21: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the endpoints of the symbols opening and point 3 defines the rear
         * of the symbol.
         *
         * Size/Shape: Points 1 and 2 determine the symbols height and point 3
         * determines its length. The vertical line at the rear of the symbol will
         * be the same height as the opening and parallel to it.
         *
         * Orientation: The opening defines the span of the breach and typically
         * faces enemy forces.
         */
        val LINE22: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the endpoints of the symbols vertical line and point 3 defines
         * the rear of the symbol.
         *
         * Size/Shape: Points 1 and 2 determine the symbols height and point 3
         * determines its length. The spacing between the symbols arrows will stay
         * proportional to the symbols height. The tip of the middle arrowhead will
         * be at the midpoint of the vertical line. The arrows will stay
         * perpendicular to the vertical line, regardless of the rotational
         * orientation of the symbol as a whole.
         *
         * Orientation: The arrows typically point toward enemy forces.
         */
        val LINE23: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Point 1 defines
         * the tip of the arrowhead. Point 2 defines the end of the straight line
         * portion of the symbol. Point 3 defines the diameter and orientation of
         * the 180 degree circular arc.
         *
         * Size/Shape: Points 1 and 2 determine the length of the straight line
         * portion of the symbol.
         * Point 3 defines which side of the line the arc is on and the diameter of
         * the arc.
         *
         * Orientation: The arrow points in the direction of the action. The tip of
         * the arrowhead may indicate the location where the action is to conclude.
         * The units current location is typically represented at the base of the
         * arc. The 180 degree circular arc is always perpendicular to the line.
         */
        val LINE24: Number

        /**
         * Anchor Points: This symbol requires exactly two anchor points. Point 1
         * defines the tip of the arrowhead and point 2 defines the rear of the
         * symbol.
         *
         * Size/Shape: Points 1 and 2 determine the length of the symbol, which
         * varies only in length.
         *
         * Orientation: The arrow typically points in the direction of the action.
         */
        val LINE25: Number

        /**
         * Anchor Points: Where four points are available Point 1 and Point 2 define
         * the ends of one arrow and Point 3 and Point 4 define the ends of the
         * other arrow. Point 1 and Point 4 define the ends of their respective
         * arrowheads. Where three points are available Point 1 defines the vertex
         * of the symbol. Points 2 and 3 define the tips of the arrowheads.
         *
         * Size/Shape: Where four points are available, Points 1 and 2 and Points
         * 3 and 4 determine the length of the arrows. Where three points are
         * available Points 1 and 2 and points 1 and 3 determine the length of the
         * arrows. The length and orientation of the arrows can vary independently.
         *
         * Orientation: Orientation is determined by the anchor points.
         * The arrowheads may touch other symbols that define the limits of the
         * task. The tactical symbol indicator is centered between point 2 and
         * point 3 when four points are in use or centered on Point 1 when three
         * points are in use.
         */
        val LINE26: Number

        /**
         * Anchor Points: Where four points are available Point 1 defines the center
         * of the circle. Point 2 defines the radius of the circle. Point 3 defines
         * the curvature of the arc. Point 4 defines the end of the arrow. Where
         * three points are available Point 1 defines the center point of the
         * circle. Point 2 defines the tip of the arrowhead. Point 3 defines the
         * 90 degree arc.
         *
         * Size/Shape: Where four points are available, Points 1 and 2 define the
         * size of the circle, which should be adjusted as needed to contain the
         * unit assigned the task. Point 3 controls the curvature of the arc.
         * Point 4 defines the end of the arrow. Where three points are available
         * Points 1 and 2 are connected by a 90 degree arc. The circle will at least
         * be large enough to accommodate a tactical symbol. Point 3 indicates on
         * which side of the line the arc is placed.
         *
         * Orientation: The arrowhead identifies the location/object to be seized
         * and the circle identifies the unit(s) assigned the task. See 5.3.11 for
         * options to accommodate multiple units.
         */
        val LINE27: Number

        /**
         * Anchor Points: This symbol requires 2 anchor points. Point 1 defines the
         * tip of the arrowhead, and point 2 defines the rear of the symbol.
         *
         * Size/Shape: Points 1 and 2 determine the length of the symbol, which
         * varies only in length.
         *
         * Orientation: The arrow typically points toward enemy forces with the tip
         * of the arrowhead indicating the location of the action.
         *
         * Duplicate of Line9 so removed in 2525E
         */
        val LINE28: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Point 1 is the
         * tip of the arrowhead. Points 2 and 3 define the endpoints of the curved
         * line on the back side of the symbol.
         *
         * Size/Shape: Points 2 and 3 determine the length of the curved line on the
         * back side of the symbol. The rear of the arrowhead line shall connect to
         * the midpoint of the line between points 2 and 3. The arrowhead line shall
         * be perpendicular to the line formed by points 2 and 3.
         *
         * Orientation: Orientation is determined by the anchor points. The back
         * side of the symbol encompasses the ambush position, while the arrowhead
         * typically points at the target.
         */
        val LINE29: Number

        /**
         * Anchor Points: This symbol may contain multiple segments. Each segment
         * requires 2 anchor points. Point numbers that define the trace of the
         * segment are sequential beginning with point 1, in increments of 1, up to
         * a max of 99 points. Each anchor point defines the endpoint of a segments
         * center line. The anchor points are Air Control Points (ACP),
         * Communications Checkpoints (CCP) or both.
         *
         * Size/Shape: Points 1 and 2 determine the length of a segment. The
         * information field inside each segment should be moveable and scalable
         * within each segment. The information box outside the symbol should be
         * placed between points 1 and 2 in such a way it does not obscure the
         * symbol.
         *
         * Orientation: The anchor points determine orientation.
         */
        val CORRIDOR1: Number

        /**
         * Anchor Points: The symbol requires N anchor points, where N is between
         * 3 and 50. Point 1 defines the tip of the arrowhead. Point N-1 defines
         * the rear of the symbol. Point N defines the back of the arrowhead.
         * Anchor points are numbered sequentially beginning with point number
         * one (1), in increments of one (1).
         *
         * Size/Shape: Points 1 through N-1 and 2 determine the symbols center line
         * and Point N determines the width. The crossover point on the symbol shall
         * occur between Points 1 and 2.
         *
         * Orientation: The arrowhead typically points toward enemy forces.
         */
        val AXIS1: Number

        /**
         * Anchor Points: The symbol requires N anchor points, where N is between 3
         * and 50. Point 1 defines the tip of the arrowhead. Point N-1 defines the
         * rear of the symbol. Point N defines the back of the arrowhead. Anchor
         * points are numbered sequentially beginning with point number one (1), in
         * increments of one (1).
         *
         * Size/Shape: Points 1 through N-1 and 2 determine the symbols center line
         * and Point N determines the width.
         *
         * Orientation: The arrowhead typically points toward enemy forces.
         */
        val AXIS2: Number

        /**
         * Anchor Points: This symbol requires three anchor points. Points 1 and 2
         * define the endpoints of the infiltration lane and point 3 defines the
         * width on one side of the lane.
         *
         * Size/Shape: Points 1 and 2 determine the center line of the symbol and
         * point 3 determines the width of the infiltration lane. The rest of the
         * symbol stays proportional to the length of the center line.
         *
         * Orientation: Orientation is determined by points 1 and 2.
         */
        val POLYLINE1: Number

        /**
         * Anchor Points: This symbol requires one anchor point. This anchor point
         * represents the center of an ellipse and, therefore, the geographic
         * location of that ellipse.
         *
         * Size/Shape: The size and shape of this symbol is determined by three
         * additional numeric values; A major axis radius, a minor axis radius, and
         * a rotation angle. The radii should be expressed in the appropriate map
         * distance units.
         *
         * Orientation: The orientation of this symbol is determined by the rotation
         * angle provided, where 0 degrees is east/west and a positive rotation
         * angle rotates the ellipse in a counter-clockwise direction.
         */
        val ELLIPSE1: Number

        /**
         * Anchor Points: This symbol requires two anchor points and a width,
         * defined in meters, to define the boundary of the area. Points 1 and 2
         * will be located in the center of two opposing sides of the rectangle.
         *
         * Size/Shape: Size: As determined by the anchor points. The anchor points
         * determine the length of the rectangle. The width, defined in meters,
         * will determine the width of the rectangle. Shape: Rectangle. The
         * information fields should be moveable and scalable.
         *
         * Orientation: As determined by the anchor points.
         */
        val RECTANGULAR1: Number

        /**
         * Anchor Points: This symbol requires one (1) anchor point to define the
         * center of the area.
         *
         * Size/Shape: Size Is determined by the anchor point, the target length
         * (in meters) and target width (in meters). A rectangular target is wider
         * and longer than 200 meters. The information fields should be moveable and
         * saleable within the area. Shape: Rectangle.
         *
         * Orientation: As determined by the Target Attitude (in mils).
         */
        val RECTANGULAR2: Number

        /**
         * Anchor Points: This symbol requires one anchor (center) point to define
         * the center of the symbol. The target tactical symbol shall be centered
         * upon the center of the area. The size and the orientation of the target
         * symbol are fixed within the area.
         *
         * Size/Shape: As determined by the anchor points. The anchor points
         * determine the areas length.
         * Width, determined in meters, will define the width of the rectangle.
         *
         * Orientation: As determined by the anchor points. The center point of the
         * area shall always have the target symbol with the same
         * upright orientation.
         */
        val RECTANGULAR3: Number

        /**
         * Anchor Points: This symbol requires one (1) anchor point and a radius.
         * Point 1 defines the center point of the symbol.
         *
         * Size/Shape: Size: The radius defines the size. Shape: Circle. The
         * information fields should be scalable within the circle.
         *
         * Orientation: Not applicable
         */
        val CIRCULAR1: Number

        /**
         * Anchor Points: This symbol requires one anchor point that defines an
         * object at a dynamic grid location. This coordinate, which pinpoints the
         * current physical location of a specific unit, weapon or acquisition
         * system, may change with the movement of the object. The symbol for that
         * object is located at the anchor point.
         *
         * Size/Shape: The size is determined by the distance in meters from the
         * object at the center of the range fan. The shapes are concentric circles.
         * A minimum of one (1) and a maximum of three (3) concentric circles can be
         * used.
         *
         * Orientation: The center point is typically centered over the known
         * location of a weapon or sensor system.
         */
        val CIRCULAR2: Number

        /**
         * Anchor Points: This graphic requires one anchor point that defines an
         * object at a dynamic grid location. This coordinate, which pinpoints the
         * current physical location of a specific unit, weapon or sensor system,
         * may change with the movement of the object. The symbol for that object
         * is located at the anchor point.
         *
         * Size/Shape: Determined by the anchor point, azimuths measured from true
         * north, and the distance (range) in meters. The Left Sector Azimuth is the
         * angle measured from true north to the left sector limit/edge of the
         * Sector Range Fan. The Right Sector Azimuth is the angle measured from
         * true north to the right sector limit/edge of the Sector Range Fan.
         * Multiple distances (ranges) and/or left and right sector limits/edges
         * of the sector, as well as altitude, may be added as required to define
         * the sector. All azimuths are in degrees. All distances (ranges) are in
         * meters. All altitudes are in feet.
         *
         * Orientation: The center point is typically centered over the known
         * location of a weapon or sensor system. The orientation may change as
         * the object moves or changes.
         */
        val ARC1: Number
    }
}

/**
 * Draw Rules for METEOROLOGICAL AND OCEANOGRAPHIC SYMBOLOGY
 *
 */
external class MODrawRules {

    companion object {
        /**
         * Usually an entry in the MilStd that is just a category containing other symbols
         * and not something that gets drawn itself.
         */
        val DONOTDRAW: Number

        /**
         * Anchor Points: This graphic requires at least three anchor points to
         * define the boundary of the area. Add as many points as necessary to
         * accurately reflect the area's size and shape.
         * Size/Shape: Scalable.
         * Orientation: Not applicable.
         */
        val AREA1: Number

        /**
         * Anchor Points: This graphic requires at least three anchor points to
         * define the boundary of the area. Add as many points as necessary to
         * accurately reflect the area's size and shape.
         * Size/Shape: Determined by the anchor points.
         * Orientation: Not applicable.
         */
        val AREA2: Number

        /**
         * Anchor Points: This graphic requires one anchor point. The center point
         * defines the center of the graphic.
         * Size/Shape: Scalable.
         * Orientation: The graphic is typically centered over the desired location.
         */
        val POINT1: Number

        /**
         * Anchor Points: This graphic requires one anchor point. The center point
         * defines the geometric center of the graphic.
         * Size/Shape: Scalable.
         * Orientation: The graphic is centered over the anchor location.
         */
        val POINT2: Number

        /**
         * Anchor Points: This graphic requires one anchor point. The center point
         * defines the center of the graphic.
         * Size/Shape: Scalable.
         * Orientation: The graphic is oriented upright on the display and operator-centered over the desired location.
         */
        val POINT3: Number

        /**
         * Anchor Points: This graphic requires one anchor point. The center point
         * defines the center of the graphic.
         * Size/Shape: Scalable.
         * Orientation: The graphic is centered over the location of the reported wind.
         */
        val POINT4: Number

        /**
         * Anchor Points: This graphic requires a minimum of two anchor points.
         * The first point defines the location of the plot circle.
         * Additional points define the wind shaft and the speed of the wind.
         * Wind speed is depicted on the shaft using a combination of the shaft
         * alone (1-2 knots), half barbs (5 knots), barbs (10 knots)
         * and pennants (50 knots). Wind speeds 5 knots or greater are rounded
         * to the nearest 5 knots. Missing wind speed is depicted by an "X" at
         * the end of the wind shaft. Winds with missing direction are not displayed.
         *
         * Size/Shape: Not applicable.
         *
         * Orientation: The shaft of the graphic is oriented with reference to
         * true north in the direction from which the wind is blowing to the
         * nearest 10 degrees. The barbs and pennants lie back from the shaft at
         * an angle of 120 degrees and are oriented to the left of the shaft in
         * the Northern Hemisphere and to the right in the Southern Hemisphere.
         * The graphic is operator-centered over the desired location.
         */
        val POINT5: Number

        /**
         * Anchor Points: This graphic requires one anchor point. The center point
         * defines the center of the graphic.
         * Size/Shape: Scalable.
         * Orientation: The graphic is centered over the location of the reported cloud cover.
         */
        val POINT6: Number

        /**
         * Anchor Points: This graphic requires one anchor point. The center point
         * defines the center of the graphic.
         * Size/Shape: Scalable.
         * Orientation: The graphic is centered over the location of the reported conditions.
         */
        val POINT7: Number

        /**
         * Anchor Points: This graphic requires one anchor point. The center point
         * defines the center of the graphic.
         * Size/Shape: Scalable.
         * Orientation: The graphic is centered over the position of the tropical system.
         */
        val POINT8: Number

        /**
         * Anchor Points: This graphic requires at least two anchor points,
         * points 1 and 2, to define the line. Additional points can be defined
         * to extend the line.
         * Size/Shape: Scalable/Curve. The curvature of the line is operator defined.
         * Orientation: The first and last anchor points determine the length of
         * the line.
         */
        val LINE1: Number

        /**
         * Anchor Points: This graphic requires at least two anchor points,
         * points 1 and 2, to define the line. Additional points can be defined to
         * extend the line.
         *
         * Size/Shape: Scalable/Curve. The points are typically connected with a
         * straight line consisting of a short line section and an alternating
         * V shape. The curvature and amplitude of the waves of the line is
         * operator defined.
         *
         * Orientation: The first and last anchor points determine the length of
         * the line. The line should be drawn so the "V" shapes are facing in
         * the direction of movement. The "V" shapes and short line segment will
         * alternate along the line.
         */
        val LINE2: Number

        /**
         * Anchor Points: This graphic requires at least two anchor points,
         * points 1 and 2, to define the line. Additional points can be defined to
         * extend the line.
         *
         * Size/Shape: Scalable/Curve. The points are typically connected with a
         * straight line consisting of a short line section and alternating two
         * dots. The curvature and amplitude of the waves of the line is
         * operator defined.
         *
         * Orientation: The first and last anchor points determine the length of the line. The two dots and the short line segment will alternate along the line.
         */
        val LINE3: Number

        /**
         * Anchor Points: This graphic requires at least two anchor points,
         * points 1 and 2, to define the line. Additional points can be defined to
         * extend the line.
         *
         * Size/Shape: Scalable/Curve. The points are typically connected with a
         * curved/wavy line consisting of a short line and one dot. The curvature
         * and amplitude of the waves of the line is operator defined.
         *
         * Orientation: The first and last anchor points determine the length of
         * the line. The dot and the short line segment will alternate along
         * the line.
         */
        val LINE4: Number

        /**
         * Anchor Points: This graphic requires at least three anchor points to
         * define the boundary of the area. Add as many points as necessary to
         * accurately reflect the area's size and shape.
         *
         * Size/Shape: Determined by the anchor points.
         *
         * Orientation: The first and last anchor points determine the length of
         * the line. The dual line segments will be parallel to slightly wider at
         * the western end.
         */
        val LINE5: Number

        /**
         * Anchor Points: This graphic requires at least two anchor points,
         * points 1 and 2, to define the line. Additional points can be defined to
         * extend the line.
         * Size/Shape: Scalable/Curve. The points are typically connected with a
         * solid straight line with alternating slanted lines connected as depicted
         * in the example to indicate convergence.
         * Orientation: The first and last anchor points determine the length of
         * the line. The alternating slanted lines will be evenly spaced along
         * the line. Orientation is determined by the anchor points.
         */
        val LINE6: Number

        /**
         * Anchor Points: This graphic requires at least two anchor points,
         * points 1 and 2, to define the line. Additional points can be defined to
         * extend the line.
         *
         * Size/Shape: Scalable/Curve. The points are typically connected with a
         * dashed straight or curved line. The curvature of the line is operator
         * defined.
         *
         * Orientation: The first and last anchor points determine the length of
         * the line. The red and green line segments will alternate along the line.
         * Orientation is determined by the anchor points.
         */
        val LINE7: Number

        /**
         * Anchor Points: This graphic requires at least two anchor points,
         * points 1 and 2, to define the line. Additional points can be defined to
         * extend the line.
         * Size/Shape: Scalable.
         * Orientation: The graphic is oriented upright on the display as shown in
         * the example and operator-centered over the desired location.
         */
        val LINE8: Number
    }
}

/**
 * Utility class that takes the 3 digit country code from the symbol ID and returns the 3 character string representation
 * of that country. For example, 840 turns into "USA" for the United States.
 */
external class GENCLookup {
    fun isReady(): Boolean
    fun get3CharCode(id: Number): String

    companion object {
        fun getInstance(): GENCLookup
    }
}

/**
 * This class holds information about the MilStd Symbol.
 * Name, geometry, point count, Draw Rule, etc...
 * Can be retrived from {@link MSLookup}.
 */
external class MSInfo {
    /**
     * @param version SymbolID.Version_2525Dch1 (11), SymbolID.Version_2525E (13)
     * @param symbolSet the 5th &amp; 6th character in the symbol Code, represents Battle Dimension
     * @param entity descriptor
     * @param entityType descriptor
     * @param entitySubType  descriptor
     * @param entityCode characters 11 - 16 in the symbol code
     * @param modifiers String[] of modifier codes
     */
    constructor (
        version: Number,
        symbolSet: String,
        entity: String,
        entityType: String,
        entitySubType: String,
        entityCode: String,
        modifiers: Array<String>
    )

    /**
     * @param version SymbolID.Version_2525Dch1 (11), SymbolID.Version_2525E (13)
     * @param symbolSet the 5th &amp; 6th character in the symbol Code, represents Battle Dimension
     * @param entity descriptor
     * @param entityType descriptor
     * @param entitySubType  descriptor
     * @param entityCode characters 11 - 16 in the symbol code
     * @param geometry "point", "line", "area"
     * @param drawRule as defined in 2525D for Control Measures and METOC (i.e. "Point1")
     * @param modifiers ArrayList of modifiers that are allowed for this symbol
     */
    constructor (
        version: Number,
        symbolSet: String,
        entity: String,
        entityType: String,
        entitySubType: String,
        entityCode: String,
        geometry: String,
        drawRule: String,
        modifiers: Array<String>
    )

    fun getVersion(): Number
    fun getName(): String
    fun getPath(): String
    fun getGeometry(): String
    fun getDrawRule(): Number
    fun getSymbolSet(): Number
    fun getEntityCode(): Number
    fun getBasicSymbolID(): String
    fun getMinPointCount(): Number
    fun getMaxPointCount(): Number
    fun getModifiers(): Array<String>

    companion object {
        fun parseSymbolSetName(symbolID: String): String
        fun parseSymbolSetName(ss: String, version: Number): String
    }
}

/**
 * Class that holds all the  objects with symbol information
 */
external class MSLookup {
    fun isReady(): Boolean

    /**
     * @param symbolID Full 20-30 digits from the symbol code
     * @return
     */
    fun getMSLInfo(symbolID: String): MSInfo?

    /**
     * @param basicID id SymbolSet + Entity code like 50110100
     * @param version like SymbolID.Version_2525Dch1
     * @return
     */
    fun getMSLInfo(basicID: String, version: Number): MSInfo?

    /**
     * returns a list of all the keys in the order they are listed in the MilStd 2525D document.
     * @param version see {@link SymbolID.Version_2525E} and {@link SymbolID.Version_2525Dch1}
     * @return
     */
    fun getIDList(version: Number): Array<String>
    fun addCustomSymbol(msInfo: MSInfo): Boolean

    companion object {
        fun getInstance(): MSLookup
    }
}

external class SVGInfo {
    constructor (id: String, measurements: Rectangle2D, svg: String)

    fun getID(): String
    fun getBbox(): Rectangle2D
    fun getSVG(): String
}

external class SVGLookup {
    fun isReady(): Boolean
    fun getSVGLInfo(id: String, version: Number): SVGInfo?
    fun getSVGOctagon(): SVGInfo?
    fun addCustomSymbol(svgInfo: SVGInfo, version: Number): Boolean

    companion object {
        fun getInstance(): SVGLookup
        fun getFrameID(symbolID: String): String
        fun getMainIconID(symbolID: String): String
        fun getMod1ID(symbolID: String): String
        fun getMod2ID(symbolID: String): String
        fun getEchelonAmplifier(symbolID: String): String
        fun getHQTFFD(symbolID: String): String
        fun getOCA(symbolID: String, useSlash: Boolean): String?
        fun getAllKeys(): Array<String>
    }
}

external interface SymbolDimensionInfo {
    /**
     * The x value the image should be centered on or the "anchor point".
     * @return {@link Integer}
     */
    fun getSymbolCenterX(): Number

    /**
     * The y value the image should be centered on or the "anchor point".
     * @return {@link Integer}
     */
    fun getSymbolCenterY(): Number

    /**
     * The point the image should be centered on or the "anchor point".
     * @return {@link Point2D}
     */
    fun getSymbolCenterPoint(): Point2D

    /**
     * minimum bounding rectangle for the core symbol. Does
     * not include modifiers, display or otherwise.
     * @return {@link Rectangle2D}
     */
    fun getSymbolBounds(): Rectangle2D

    /**
     * Dimension of the entire image.
     * @return {@link Rectangle2D}
     */
    fun getImageBounds(): Rectangle2D
}

external class SVGSymbolInfo : SymbolDimensionInfo {
    constructor (svg: String, anchorPoint: Point2D, symbolBounds: Rectangle2D, svgBounds: Rectangle2D)

    fun getSVGDataURI(): String
    fun getSVG(): String

    /**
     * The x value the image should be centered on or the "anchor point".
     * @return
     */
    override fun getSymbolCenterX(): int

    /**
     * The y value the image should be centered on or the "anchor point".
     * @return
     */
    override fun getSymbolCenterY(): int

    /**
     * The point the image should be centered on or the "anchor point".
     * @return
     */
    override fun getSymbolCenterPoint(): Point2D

    /**
     * minimum bounding rectangle for the core symbol. Does
     * not include modifiers, display or otherwise.
     * @return
     */
    override fun getSymbolBounds(): Rectangle2D

    /**
     * Dimension of the entire image.
     * @return
     */
    override fun getImageBounds(): Rectangle2D
}

/**
 * Has various utility functions for prcessing the symbol code.
 * See {@link SymbolID} for additional functions related to parsing the symbol code.
 *
 */
external class SymbolUtilities {

    companion object {
        /**
         * Determines if a String represents a valid number
         *
         * @param text string
         * @return "1.56" == true, "1ab" == false
         */
        fun isNumber(text: String): Boolean

        /**
         * Converts a Java Date object into a properly formatted String for W or W1.
         * DDHHMMSSZMONYYYY
         * Field W: D = day, H = hour, M = minute, S = second, Z = Greenwich or local time, MON= month and Y = year.
         * @param date {@link Date}
         * @return string
         */
        fun getDateLabel(date: Date): String

        /**
         * Determines if a symbol, based on it's symbol ID, can have the specified modifier/amplifier.
         * @param symbolID 30 Character string
         * @param modifier {@link Modifiers}
         * @return
         */
        fun hasModifier(symbolID: String, modifier: String): Boolean

        /**
         * Gets Basic Symbol ID which is the Symbol Set + Entity Code
         * @param id 30 Character string
         * @return 8 character string (Symbol Set + Entity Code)
         */
        fun getBasicSymbolID(id: String): String

        /**
         * Gets the basic Symbol ID for a 2525C symbol
         * S*F*GPU---*****
         * G*G*GPP---****X
         * @param strSymbolID 15 Character string
         * @return 15 Character string
         * @deprecated function will be removed
         */
        fun getBasicSymbolID2525C(strSymbolID: String): String

        /**
         * Attempts to resolve a bad symbol ID into a value that can be found in {@link MSLookup}.
         * If it fails, it will return the symbol code for a invalid symbol which is displayed as
         * an inverted question mark (110098000010000000000000000000)
         * @param symbolID 30 character string
         * @return 30 character string representing the resolved symbol ID.
         */
        fun reconcileSymbolID(symbolID: String): String

        /**
         * Gets line color used if no line color has been set. The color is specified based on the affiliation of
         * the symbol and whether it is a unit or not.
         * @param symbolID 30 character string
         * @return
         */
        fun getLineColorOfAffiliation(symbolID: String): Color?

        /**
         * For Control Measures, returns the default color for a symbol when it differs from the
         * affiliation line color.  If there is no default color, returns the value from {@link getLineColorOfAffiliation()}
         * @param symbolID 30 Character string
         * @return
         */
        fun getDefaultLineColor(symbolID: String): Color?

        /**
         * Checks if a symbol should be filled by default
         *
         * @param strSymbolID The 20 digit representation of the 2525D symbol
         * @return true if there is a default fill
         */
        fun hasDefaultFill(strSymbolID: String): Boolean

        /**
         * Determines if the symbol is a tactical graphic
         *
         * @param strSymbolID 30 Character string
         * @return true if symbol set is 25 (control measure), or is a weather graphic
         */
        fun isTacticalGraphic(strSymbolID: String): Boolean

        /**
         * Determines if the Symbol can be rendered as a multipoint graphic and not just as an icon
         * @param symbolID 30 Character string
         * @return
         */
        fun isMultiPoint(symbolID: String): Boolean
        fun isActionPoint(symbolID: String): Boolean

        /**
         * Control Measures and Tactical Graphics that have labels but not with the Action Point layout
         * @param strSymbolID 30 Character string
         * @return
         * @deprecated see {@link isSPWithSpecialModifierLayout(String)}
         */
        fun isTGSPWithSpecialModifierLayout(strSymbolID: String): Boolean

        /**
         * Returns the fill color for the symbol based on its affiliation
         * @param symbolID 30 Character string
         * @return
         */
        fun getFillColorOfAffiliation(symbolID: String): Color?

        /**
         *
         * @param symbolID 30 Character string
         * @param modifier {@link Modifiers}
         * @return
         * @deprecated see {@link hasModifier()}
         */
        fun canSymbolHaveModifier(symbolID: String, modifier: String): Boolean

        /**
         * Checks if the Symbol Code has FDI set.
         * Does not check if the symbol can have an FDI.
         * @param symbolID 30 Character string
         * @return
         */
        fun hasFDI(symbolID: String): Boolean

        /**
         * Returns true if graphic is protection graphic (obstacles which render green)
         * @param symbolID 30 Character string
         * @return
         */
        fun isGreenProtectionGraphic(symbolID: String): Boolean

        /***
         * Returns true if graphic is protection graphic (obstacles which render green)
         * Assumes control measure symbol code where SS == 25
         * @param entity
         * @param entityType
         * @param entitySubtype
         * @return
         */
        fun isGreenProtectionGraphic(entity: int, entityType: int, entitySubtype: int): Boolean

        /**
         * Returns true if Symbol ID represents a chemical, biological, radiological or nuclear incident.
         * @param symbolID 30 Character string
         * @return
         */
        fun isCBRNEvent(symbolID: String): Boolean

        /**
         * Returns true if Symbol ID represents a Sonobuoy.
         * @param symbolID 30 Character string
         * @return
         */
        fun isSonobuoy(symbolID: String): Boolean

        /**
         * Obstacles are generally required to have a green line color
         * @param symbolID 30 Character string
         * @return
         * @deprecated see {@link isGreenProtectionGraphic()}
         */
        fun isObstacle(symbolID: String): Boolean

        /**
         * Return true if symbol is from the Atmospheric, Oceanographic or Meteorological Space Symbol Sets.
         * @param symbolID 30 Character string
         * @return
         */
        fun isWeather(symbolID: String): Boolean

        /**
         * Returns true if the symbol has the HQ staff indicated by the symbol ID
         * @param symbolID 30 Character string
         * @return
         */
        fun isHQ(symbolID: String): Boolean

        /**
         * Checks if this is a single point control measure or meteorological graphic with a unique layout.
         * Basically anything that's not an action point style graphic with modifiers
         * @param symbolID 30 Character string
         * @return
         */
        fun isSPWithSpecialModifierLayout(symbolID: String): Boolean

        /**
         * Gets the anchor point for single point Control Measure as the anchor point isn't always they center of the symbol.
         * @param symbolID 30 Character string
         * @param bounds {@link Rectangle2D} representing the bound of the core symbol in the image.
         * @return  representing the point in the image that is the anchor point of the symbol.
         */
        fun getCMSymbolAnchorPoint(symbolID: String, bounds: Rectangle2D): Point

        /**
         * Returns true if the symbol is an installation
         * @param symbolID 30 Character string
         * @return
         */
        fun isInstallation(symbolID: String): Boolean

        /**
         * Returns true if the symbol is from an air based symbol set
         * @param symbolID 30 Character string
         * @return
         */
        fun isAir(symbolID: String): Boolean

        /**
         * Returns true if the symbol is from a space based symbol set
         * @param symbolID 30 Character string
         * @return
         */
        fun isSpace(symbolID: String): Boolean

        /**
         * Returns true if the symbol is from a land based symbol set
         * @param symbolID 30 Character string
         * @return
         */
        fun isLand(symbolID: String): Boolean

        /**
         * Returns true if the symbol ID has the task for indicator
         * @param symbolID 30 Character string
         * @return
         */
        fun isTaskForce(symbolID: String): Boolean

        /**
         * Returns true if the symbol ID indicates the context is Reality
         * @param symbolID 30 Character string
         * @return
         */
        fun isReality(symbolID: String): Boolean

        /**
         * Returns true if the symbol ID indicates the context is Exercise
         * @param symbolID 30 Character string
         * @return
         */
        fun isExercise(symbolID: String): Boolean

        /**
         * Returns true if the symbol ID indicates the context is Simulation
         * @param symbolID 30 Character string
         * @return
         */
        fun isSimulation(symbolID: String): Boolean

        /**
         * Reads the Symbol ID string and returns the text that represents the echelon
         * code.
         * @param echelon  from positions 9-10 in the symbol ID
         * See {@link SymbolID.getAmplifierDescriptor()}
         * @return string (23 (Army) would be "XXXX")
         */
        fun getEchelonText(echelon: int): String

        /**
         * Returns the Standard Identity Modifier based on the Symbol ID
         * @param symbolID 30 Character string
         * @return string
         */
        fun getStandardIdentityModifier(symbolID: String): String

        /**
         * Returns true if the unit has a rectangle frame
         * @param symbolID 30 Character string
         * @return
         */
        fun hasRectangleFrame(symbolID: String): Boolean

        /**
         * Returns the height ratio for the unit specified by the symbol ID
         * Based on Figure 4 in 2525E.
         * @param symbolID 30 Character string
         * @return
         */
        fun getUnitRatioHeight(symbolID: String): double

        /**
         * Returns the width ratio for the unit specified by the symbol ID
         * Based on Figure 4 in 2525E.
         * @param symbolID 30 Character string
         * @return
         */
        fun getUnitRatioWidth(symbolID: String): double
    }
}

external interface SettingsEventListener {
    fun SettingsEventChanged(type: String): Unit
}

/**
 *Static class that holds the setting for the JavaRenderer.
 * Allows different parts of the renderer to know what
 * values are being used.
 *
 */
external class RendererSettings {
    fun addEventListener(sel: SettingsEventListener): Unit

    /**
     * None, outline (default), or filled background.
     * If set to OUTLINE, TextOutlineWidth changed to default of 4.
     * If set to OUTLINE_QUICK, TextOutlineWidth changed to default of 1.
     * Use setTextOutlineWidth if you'd like a different value.
     * @param textBackgroundMethod like RenderSettings.TextBackgroundMethod_NONE
     */
    fun setTextBackgroundMethod(textBackgroundMethod: int): Unit

    /**
     * None, outline (default), or filled background.
     * @return method like RenderSettings.TextBackgroundMethod_NONE
     */
    fun getTextBackgroundMethod(): int

    /**
     * default size single point icons will render on the map
     * @param size
     */
    fun setDefaultPixelSize(size: int): Unit

    /**
     * default size single point icons will render on the map
     * @return
     */
    fun getDefaultPixelSize(): int

    /**
     * Set the operational condition modifier to be slashes or bars
     * @param value like RendererSettings.OperationalConditionModifierType_SLASH
     */
    fun setOperationalConditionModifierType(value: int): Unit
    fun getOperationalConditionModifierType(): int
    fun setSeaMineRenderMethod(method: int): Unit
    fun getSeaMineRenderMethod(): int

    /**
     * For lines symbols with "decorations" like FLOT or LOC, when points are
     * too close together, we will start dropping points until we get enough
     * space between 2 points to draw the decoration.  Without this, when points
     * are too close together, you run the chance that the decorated line will
     * look like a plain line because there was no room between points to
     * draw the decoration.
     * @param value boolean
     */
    fun setUseLineInterpolation(value: Boolean): Unit

    /**
     * Returns the current setting for Line Interpolation.
     * @return boolean
     */
    fun getUseLineInterpolation(): Boolean

    /**
     * set the screen DPI so the renderer can take DPI into account when
     * rendering for things like dashed lines and decorated lines.
     * @param value
     */
    fun setDeviceDPI(value: int): Unit
    fun getDeviceDPI(): int

    /**
     * Collapse Modifiers for fire support areas when the symbol isn't large enough to show all
     * the labels.  Identifying label will always be visible.  Zooming in, to make the symbol larger,
     * will make more modifiers visible.  Resizing the symbol can also make more modifiers visible.
     * @param value boolean
     */
    fun setAutoCollapseModifiers(value: Boolean): Unit
    fun getAutoCollapseModifiers(): Boolean

    /**
     * if true (default), when HQ Staff is present, location will be indicated by the free
     * end of the staff
     * @param value
     */
    fun setCenterOnHQStaff(value: Boolean): Unit

    /**
     * if true (default), when HQ Staff is present, location will be indicated by the free
     * end of the staff
     */
    fun getCenterOnHQStaff(): Boolean
    /**
     * if RenderSettings.TextBackgroundMethod_OUTLINE is used,
     * the outline will be this many pixels wide.
     *
     * @param width
     * @deprecated - controlled within the renderer
     */
    /**
     * if RenderSettings.TextBackgroundMethod_OUTLINE is used,
     * the outline will be this many pixels wide.
     * @return
     */
    fun getTextOutlineWidth(): int
    /**
     * Refers to text color of modifier labels
     * @return
     *
     */
    /**
     * Refers to text color of modifier labels
     * Default Color is Black.  If NULL, uses line color of symbol
     * @param value
     *
     */
    /**
     * Refers to background color of modifier labels
     * @return
     *
     */
    /**
     * Refers to text color of modifier labels
     * Default Color is White.
     * Null value means the optimal background color (black or white)
     * will be chose based on the color of the text.
     * @param value
     *
     */
    /**
     * Value from 0 to 255. The closer to 0 the lighter the text color has to be
     * to have the outline be black. Default value is 160.
     * @param value
     */
    fun setTextBackgroundAutoColorThreshold(value: int): Unit

    /**
     * Value from 0 to 255. The closer to 0 the lighter the text color has to be
     * to have the outline be black. Default value is 160.
     * @return
     */
    fun getTextBackgroundAutoColorThreshold(): int

    /**
     * This applies to Single Point Tactical Graphics.
     * Setting this will determine the default value for milStdSymbols when created.
     * 0 for no outline,
     * 1 for outline thickness of 1 pixel,
     * 2 for outline thickness of 2 pixels,
     * greater than 2 is not currently recommended.
     * @deprecated
     * @param width
     */
    fun setSinglePointSymbolOutlineWidth(width: int): Unit

    /**
     * This applies to Single Point Tactical Graphics.
     * @return
     * @deprecated
     */
    fun getSinglePointSymbolOutlineWidth(): int
    fun setOutlineSPControlMeasures(value: Boolean): Unit
    fun getOutlineSPControlMeasures(): Boolean
    fun setActionPointDefaultFill(value: Boolean): Unit
    fun getActionPointDefaultFill(): Boolean

    /**
     * false to use label font size
     * true to scale it using symbolPixelBounds / 3.5
     * @param value
     */
    fun setScaleEchelon(value: Boolean): Unit

    /**
     * Returns the value determining if we scale the echelon font size or
     * just match the font size specified by the label font.
     * @return true or false
     */
    fun getScaleEchelon(): Boolean

    /**
     * Determines how to draw the Affiliation modifier.
     * True to draw as modifier label in the "E/F" location.
     * False to draw at the top right corner of the symbol
     */
    fun setDrawAffiliationModifierAsLabel(value: Boolean): Unit

    /**
     * True to draw as modifier label in the "E/F" location.
     * False to draw at the top right corner of the symbol
     */
    fun getDrawAffiliationModifierAsLabel(): Boolean

    /**
     * Sets the font to be used for modifier labels
     * @param name Like "arial"
     * @param weight Like "normal" or "bold"
     * @param size Like 12
     */
    fun setLabelFont(name: String, weight: String, size: int): Unit

    /**
     *
     * @param name Like "arial"
     * @param type Like Font.BOLD
     * @param size Like 12
     */
    fun setLabelFont(name: String, type: int, size: int): Unit
    fun setMPLabelFont(name: String, weight: String, size: int): Unit
    fun setMPLabelFont(name: String, weight: String, size: int, kmlScale: float): Unit
    fun setMPLabelFont(name: String, type: int, size: int): Unit
    fun setMPLabelFont(name: String, type: int, size: int, kmlScale: float): Unit

    /**
     * the font name to be used for modifier labels
     * @return name of the label font
     */
    fun getLabelFontName(): String

    /**
     * Like Font.BOLD
     * @return type of the label font
     */
    fun getLabelFontType(): int

    /**
     * get font point size
     * @return size of the label font
     */
    fun getLabelFontSize(): int

    /**
     * get font object used for labels
     * @return Font object
     */
    fun getLabelFont(): Font

    /**
     * get font object used for labels
     * @return Font object
     */
    fun getMPLabelFont(): Font
    fun getKMLLabelScale(): float

    /**
     * the font name to be used for modifier labels
     * @return name of the label font
     */
    fun getMPLabelFontName(): String

    /**
     * Like Font.BOLD
     * @return type of the label font
     */
    fun getMPLabelFontType(): int

    /**
     * get font point size
     * @return size of the label font
     */
    fun getMPLabelFontSize(): int

    /**
     ** Get a boolean indicating between the use of ENY labels in all segments (false) or
     * to only set 2 labels one at the north and the other one at the south of the graphic (true).
     * @return {boolean}
     */
    fun getTwoLabelOnly(): Boolean

    /**
     * Set a boolean indicating between the use of ENY labels in all segments (false) or
     * to only set 2 labels one at the north and the other one at the south of the graphic (true).
     * @param TwoLabelOnly
     */
    fun setTwoLabelOnly(TwoLabelOnly: Boolean): Unit

    /**
     * When true, if the main icon is normally small to allow room for sector modifiers,
     * make it larger when no sector modifiers are present for better visibility.
     * @param scaleMainIcon
     */
    fun setScaleMainIcon(scaleMainIcon: Boolean): Unit

    /**
     * When true, if the main icon is normally small to allow room for sector modifiers,
     * main icon is made larger when no sector modifiers are present for better visibility.
     */
    fun getScaleMainIcon(): Boolean

    /**
     * get the preferred fill affiliation color for units.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getFriendlyUnitFillColor(): Color

    /**
     * Set the preferred fill affiliation color for units
     *
     * @param friendlyUnitFillColor Color like  Color(255, 255, 255)
     *
     * */
    fun setFriendlyUnitFillColor(friendlyUnitFillColor: Color): Unit

    /**
     * get the preferred fill affiliation color for units.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getHostileUnitFillColor(): Color

    /**
     * Set the preferred fill affiliation color for units
     *
     * @param hostileUnitFillColor Color like  Color(255, 255, 255)
     *
     * */
    fun setHostileUnitFillColor(hostileUnitFillColor: Color): Unit

    /**
     * get the preferred fill affiliation color for units.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getNeutralUnitFillColor(): Color

    /**
     * Set the preferred line affiliation color for units
     *
     * @param neutralUnitFillColor Color like  Color(255, 255, 255)
     *
     * */
    fun setNeutralUnitFillColor(neutralUnitFillColor: Color): Unit

    /**
     * get the preferred fill affiliation color for units.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getUnknownUnitFillColor(): Color

    /**
     * Set the preferred fill affiliation color for units
     *
     * @param unknownUnitFillColor Color like  Color(255, 255, 255)
     *
     * */
    fun setUnknownUnitFillColor(unknownUnitFillColor: Color): Unit

    /**
     * get the preferred fill affiliation color for graphics.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getHostileGraphicFillColor(): Color

    /**
     * Set the preferred fill affiliation color for graphics
     *
     * @param hostileGraphicFillColor Color like  Color(255, 255, 255)
     *
     * */
    fun setHostileGraphicFillColor(hostileGraphicFillColor: Color): Unit

    /**
     * get the preferred fill affiliation color for graphics.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getFriendlyGraphicFillColor(): Color

    /**
     * Set the preferred fill affiliation color for graphics
     *
     * @param friendlyGraphicFillColor Color like  Color(255, 255, 255)
     *
     * */
    fun setFriendlyGraphicFillColor(friendlyGraphicFillColor: Color): Unit

    /**
     * get the preferred fill affiliation color for graphics.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getNeutralGraphicFillColor(): Color

    /**
     * Set the preferred fill affiliation color for graphics
     *
     * @param neutralGraphicFillColor Color like  Color(255, 255, 255)
     *
     * */
    fun setNeutralGraphicFillColor(neutralGraphicFillColor: Color): Unit

    /**
     * get the preferred fill affiliation color for graphics.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getUnknownGraphicFillColor(): Color

    /**
     * Set the preferred fill affiliation color for graphics
     *
     * @param unknownGraphicFillColor Color like  Color(255, 255, 255)
     *
     * */
    fun setUnknownGraphicFillColor(unknownGraphicFillColor: Color): Unit

    /**
     * get the preferred line affiliation color for units.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getFriendlyUnitLineColor(): Color

    /**
     * Set the preferred line affiliation color for units
     *
     * @param friendlyUnitLineColor Color like  Color(255, 255, 255)
     *
     * */
    fun setFriendlyUnitLineColor(friendlyUnitLineColor: Color): Unit

    /**
     * get the preferred line   affiliation color for units.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getHostileUnitLineColor(): Color

    /**
     * Set the preferred line affiliation color for units
     *
     * @param hostileUnitLineColor Color like  Color(255, 255, 255)
     *
     * */
    fun setHostileUnitLineColor(hostileUnitLineColor: Color): Unit

    /**
     * get the preferred line affiliation color for units.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getNeutralUnitLineColor(): Color

    /**
     * Set the preferred line affiliation color for units
     *
     * @param neutralUnitLineColor Color like  Color(255, 255, 255)
     *
     * */
    fun setNeutralUnitLineColor(neutralUnitLineColor: Color): Unit

    /**
     * get the preferred line affiliation color for units.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getUnknownUnitLineColor(): Color

    /**
     * Set the preferred line affiliation color for units
     *
     * @param unknownUnitLineColor Color like  Color(255, 255, 255)
     *
     * */
    fun setUnknownUnitLineColor(unknownUnitLineColor: Color): Unit

    /**
     * get the preferred line affiliation color for graphics.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getFriendlyGraphicLineColor(): Color

    /**
     * Set the preferred line affiliation color for graphics
     *
     * @param friendlyGraphicLineColor Color like  Color(255, 255, 255)
     *
     * */
    fun setFriendlyGraphicLineColor(friendlyGraphicLineColor: Color): Unit

    /**
     * get the preferred line affiliation color for graphics.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getHostileGraphicLineColor(): Color

    /**
     * Set the preferred line affiliation color for graphics
     *
     * @param hostileGraphicLineColor Color like  Color(255, 255, 255)
     *
     * */
    fun setHostileGraphicLineColor(hostileGraphicLineColor: Color): Unit

    /**
     * get the preferred line affiliation color for graphics.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getNeutralGraphicLineColor(): Color

    /**
     * Set the preferred line affiliation color for graphics
     *
     * @param neutralGraphicLineColor Color like  Color(255, 255, 255)
     *
     * */
    fun setNeutralGraphicLineColor(neutralGraphicLineColor: Color): Unit

    /**
     * get the preferred line affiliation color for graphics.
     *
     * @return Color like  Color(255, 255, 255)
     *
     * */
    fun getUnknownGraphicLineColor(): Color

    /**
     * Set the preferred line affiliation color for graphics
     *
     * @param unknownGraphicLineColor Color like  Color(255, 255, 255)
     *
     * */
    fun setUnknownGraphicLineColor(unknownGraphicLineColor: Color): Unit

    /**
     * Set the preferred line and fill affiliation color for tactical graphics.
     *
     * @param friendlyGraphicLineColor Color
     * @param hostileGraphicLineColor Color
     * @param neutralGraphicLineColor Color
     * @param unknownGraphicLineColor Color
     * @param friendlyGraphicFillColor Color
     * @param hostileGraphicFillColor Color
     * @param neutralGraphicFillColor Color
     * @param unknownGraphicFillColor Color
     */
    fun setGraphicPreferredAffiliationColors(
        friendlyGraphicLineColor: Color,
        hostileGraphicLineColor: Color,
        neutralGraphicLineColor: Color,
        unknownGraphicLineColor: Color,
        friendlyGraphicFillColor: Color,
        hostileGraphicFillColor: Color,
        neutralGraphicFillColor: Color,
        unknownGraphicFillColor: Color
    ): Unit

    /**
     * Set the preferred line and fill affiliation color for units and tactical graphics.
     *
     * @param friendlyUnitLineColor Color like  Color(255, 255, 255). Set to null to ignore setting
     * @param hostileUnitLineColor Color
     * @param neutralUnitLineColor Color
     * @param unknownUnitLineColor Color
     * @param friendlyUnitFillColor Color
     * @param hostileUnitFillColor Color
     * @param neutralUnitFillColor Color
     * @param unknownUnitFillColor Color
     */
    fun setUnitPreferredAffiliationColors(
        friendlyUnitLineColor: Color,
        hostileUnitLineColor: Color,
        neutralUnitLineColor: Color,
        unknownUnitLineColor: Color,
        friendlyUnitFillColor: Color,
        hostileUnitFillColor: Color,
        neutralUnitFillColor: Color,
        unknownUnitFillColor: Color
    ): Unit

    companion object {
        /**
         * There will be no background for text
         */
        val TextBackgroundMethod_NONE: int

        /**
         * There will be a colored box behind the text
         */
        val TextBackgroundMethod_COLORFILL: int

        /**
         * There will be an adjustable outline around the text (expensive)
         * Outline width of 4 is recommended.
         */
        val TextBackgroundMethod_OUTLINE: int

        /**
         * A different approach for outline which is quicker and seems to use
         * less memory.  Also, you may do well with a lower outline thickness setting
         * compared to the regular outlining approach.  Outline Width of 1 is
         * recommended.
         */
        val TextBackgroundMethod_OUTLINE_QUICK: int
        var OperationalConditionModifierType_SLASH: int
        var OperationalConditionModifierType_BAR: int
        val SeaMineRenderMethod_MEDAL: int
        val SeaMineRenderMethod_ALT: int
        var _SeaMineRenderMethod: int
        fun getInstance(): RendererSettings
    }
}

/**
 * Utility class for helping to parse out parts of the symbol ID.
 *
 */
external class SymbolID {

    companion object {
        val Version_2525D: Number
        val Version_2525Dch1: Number

        /**
         * @deprecated withdrawn from standard
         */
        val Version_APP6Dch2: Number
        val Version_2525E: Number
        val StandardIdentity_Context_Reality: Number
        val StandardIdentity_Context_Exercise: Number
        val StandardIdentity_Context_Simulation: Number
        val StandardIdentity_Affiliation_Pending: Number
        val StandardIdentity_Affiliation_Unknown: Number
        val StandardIdentity_Affiliation_AssumedFriend: Number
        val StandardIdentity_Affiliation_Friend: Number
        val StandardIdentity_Affiliation_Neutral: Number
        val StandardIdentity_Affiliation_Suspect_Joker: Number
        val StandardIdentity_Affiliation_Hostile_Faker: Number
        val SymbolSet_Unknown: Number
        val SymbolSet_Air: Number
        val SymbolSet_AirMissile: Number
        val SymbolSet_Space: Number
        val SymbolSet_SpaceMissile: Number
        val SymbolSet_LandUnit: Number
        val SymbolSet_LandCivilianUnit_Organization: Number
        val SymbolSet_LandEquipment: Number
        val SymbolSet_LandInstallation: Number
        val SymbolSet_ControlMeasure: Number
        val SymbolSet_DismountedIndividuals: Number
        val SymbolSet_SeaSurface: Number
        val SymbolSet_SeaSubsurface: Number
        val SymbolSet_MineWarfare: Number
        val SymbolSet_Activities: Number
        val SymbolSet_Atmospheric: Number
        val SymbolSet_Oceanographic: Number
        val SymbolSet_MeteorologicalSpace: Number
        val SymbolSet_SignalsIntelligence: Number
        val SymbolSet_SignalsIntelligence_Space: Number
        val SymbolSet_SignalsIntelligence_Air: Number
        val SymbolSet_SignalsIntelligence_Land: Number
        val SymbolSet_SignalsIntelligence_SeaSurface: Number
        val SymbolSet_SignalsIntelligence_SeaSubsurface: Number
        val SymbolSet_CyberSpace: Number
        val SymbolSet_InvalidSymbol: Number
        val SymbolSet_VersionExtensionFlag: Number
        val Status_Present: Number
        val Status_Planned_Anticipated_Suspect: Number
        val Status_Present_FullyCapable: Number
        val Status_Present_Damaged: Number
        val Status_Present_Destroyed: Number
        val Status_Present_FullToCapacity: Number
        val Status_Present_VersionExtensionFlag: Number
        val HQTFD_Unknown: Number
        val HQTFD_FeintDummy: Number
        val HQTFD_Headquarters: Number
        val HQTFD_FeintDummy_Headquarters: Number
        val HQTFD_TaskForce: Number
        val HQTFD_FeintDummy_TaskForce: Number
        val HQTFD_TaskForce_Headquarters: Number
        val HQTFD_FeintDummy_TaskForce_Headquarters: Number
        val HQTFD_VersionExtensionFlag: Number
        val Echelon_Unknown: Number
        val Echelon_Team_Crew: Number
        val Echelon_Squad: Number
        val Echelon_Section: Number
        val Echelon_Platoon_Detachment: Number
        val Echelon_Company_Battery_Troop: Number
        val Echelon_Battalion_Squadron: Number
        val Echelon_Regiment_Group: Number
        val Echelon_Brigade: Number
        val Echelon_VersionExtensionFlag: Number
        val Echelon_Division: Number
        val Echelon_Corps_MEF: Number
        val Echelon_Army: Number
        val Echelon_ArmyGroup_Front: Number
        val Echelon_Region_Theater: Number
        val Echelon_Region_Command: Number
        val Echelon_VersionExtensionFlag2: Number
        val Mobility_Unknown: Number
        val Mobility_WheeledLimitedCrossCountry: Number
        val Mobility_WheeledCrossCountry: Number
        val Mobility_Tracked: Number
        val Mobility_Wheeled_Tracked: Number
        val Mobility_Towed: Number
        val Mobility_Rail: Number
        val Mobility_PackAnimals: Number
        val Mobility_OverSnow: Number
        val Mobility_Sled: Number
        val Mobility_Barge: Number
        val Mobility_Amphibious: Number
        val Mobility_ShortTowedArray: Number
        val Mobility_LongTowedArray: Number
        val Leadership_Individual: Number
        val FrameShape_Unknown: String
        val FrameShape_Space: String
        val FrameShape_Air: String
        val FrameShape_LandUnit: String
        val FrameShape_LandEquipment_SeaSurface: String
        val FrameShape_LandInstallation: String
        val FrameShape_DismountedIndividuals: String
        val FrameShape_SeaSubsurface: String
        val FrameShape_Activity_Event: String
        val FrameShape_Cyberspace: String

        /**
         * Attempts to resolve a bad symbol ID into a value that can be found in {@link MSLookup}.
         * If it fails, it will return the symbol code for a invalid symbol which is displayed as
         * an inverted question mark (110098000010000000000000000000)
         * @param symbolID 30 character string
         * @return 30 character string representing the resolved symbol ID.
         * @deprecated See {@link SymbolUtilities.reconcileSymbolID()}
         */
        fun reconcileSymbolID(symbolID: String): String

        /**
         * Gets the version number from the Symbol ID at positions 1-2
         * @param symbolID 30 character string
         * @return number like {@link SymbolID.Version_2525Dch1} (11)
         */
        fun getVersion(symbolID: String): Number

        /**
         * Sets the version number of the Symbol ID at positions 1-2
         * @param symbolID 30 character string
         * @param ver number like {@link SymbolID.Version_2525Dch1} (11)
         * @return updated 30 character string symbol ID
         */
        fun setVersion(symbolID: String, ver: Number): String

        /**
         * Gets the version number from the Symbol ID at positions 3-4.
         * Restricted and No-Strike values are NATO only.
         * @param symbolID 30 character string
         * @return number, number will not be padded if it starts with a '0'
         */
        fun getStandardIdentity(symbolID: String): Number

        /**
         * Sets the version number of the Symbol ID at positions 3-4
         * @param symbolID 30 character string
         * @param si number If number is a single digit, will pad with a '0' before inserting into symbol ID
         * @return updated 30 character string symbol ID
         */
        fun setStandardIdentity(symbolID: String, si: Number): String

        /**
         * Get Context (Reality (0), Exercise (1), Simulation (2)) at position 3
         * Higher values are NATO only
         * @param symbolID 30 Character string
         * @return number
         */
        fun getContext(symbolID: String): Number

        /**
         * Set Context (Reality (0), Exercise (1), Simulation (2)) at position 3
         * @param symbolID 30 Character string
         * @param context number
         * @return string updated Symbol ID.
         */
        fun setContext(symbolID: String, context: Number): String

        /**
         * Get Affiliation from position 4
         * @param symbolID 30 Character string
         * @return number like {@link SymbolID.StandardIdentity_Affiliation_Friend}
         */
        fun getAffiliation(symbolID: String): Number

        /**
         * Set Affiliation at position 4
         * @param symbolID 30 Character string
         * @param affiliation like {@link SymbolID.StandardIdentity_Affiliation_Friend}
         * @return string updated Symbol ID.
         */
        fun setAffiliation(symbolID: String, affiliation: Number): String

        /**
         * Get Symbol Set from positions 5-6
         * @param symbolID 30 Character string
         * @return number like {@link SymbolID.SymbolSet_LandCivilianUnit_Organization}
         */
        fun getSymbolSet(symbolID: String): Number

        /**
         * Set Symbol Set at positions 5-6
         * @param symbolID 30 Character string
         * @param ss like {@link SymbolID.SymbolSet_LandCivilianUnit_Organization}
         * @return string updated Symbol ID.
         */
        fun setSymbolSet(symbolID: String, ss: Number): String

        /**
         * Get Symbol Set from position 7
         * @param symbolID 30 Character string
         * @return number like {@link SymbolID.Status_Present}
         */
        fun getStatus(symbolID: String): Number

        /**
         * Set Symbol Set at position 7
         * @param symbolID 30 Character string
         * @param status like {@link SymbolID.Status_Present}
         * @return string updated Symbol ID.
         */
        fun setStatus(symbolID: String, status: Number): String

        /**
         * Get Symbol Set from position 8
         * @param symbolID 30 Character string
         * @return number like {@link SymbolID.HQTFD_Headquarters}
         */
        fun getHQTFD(symbolID: String): Number

        /**
         * Set Symbol Set at position 8
         * @param symbolID 30 Character string
         * @param HQTFD like {@link SymbolID.HQTFD_Headquarters}
         * @return string updated Symbol ID.
         */
        fun setHQTFD(symbolID: String, HQTFD: Number): String

        /**
         * Get Amplifier Descriptor which can describe things like
         * Echelon / Mobility / Towed Array / Leadership Indicator from positions 9-10
         * @param symbolID 30 Character string
         * @return number
         */
        fun getAmplifierDescriptor(symbolID: String): Number

        /**
         * Set Amplifier Descriptor which can describe things like
         * Echelon / Mobility / Towed Array / Leadership Indicator at positions 9-10
         * @param symbolID 30 Character string
         * @param ad
         * @return string
         */
        fun setAmplifierDescriptor(symbolID: String, ad: Number): String

        /**
         * Get Entity Code from positions 11-16.
         * These six digits identify a unique symbol within a symbol set.
         * @param symbolID 30 Character string
         * @return number
         */
        fun getEntityCode(symbolID: String): Number

        /**
         * Set Entity Code at positions 11-16.
         * These six digits identify a unique symbol within a symbol set.
         * @param symbolID 30 Character string
         * @param entityCode number
         * @return string
         */
        fun setEntityCode(symbolID: String, entityCode: Number): String

        /**
         * Get Entity from positions 11-12.
         * @param symbolID 30 Character string
         * @return number
         */
        fun getEntity(symbolID: String): Number

        /**
         * Get Entity Type from positions 13-14.
         * @param symbolID 30 Character string
         * @return number
         */
        fun getEntityType(symbolID: String): Number

        /**
         * Get Entity Subtype from positions 15-16.
         * @param symbolID 30 Character string
         * @return number
         */
        fun getEntitySubtype(symbolID: String): Number

        /**
         * Get Sector 1 Modifier from positions 17-18.
         * @param symbolID 30 Character string
         * @return number
         */
        fun getModifier1(symbolID: String): Number

        /**
         * Set Sector 1 Modifier at positions 17-18.
         * @param symbolID 30 Character string
         * @param mod1 number
         * @return string
         */
        fun setModifier1(symbolID: String, mod1: Number): String

        /**
         * Get Common Sector 1 Modifier from position 21.
         * @param symbolID 30 Character string
         * @return number
         */
        fun getCommonModifier1(symbolID: String): Number

        /**
         * Set Common Sector 1 Modifier at position 21.
         * @param symbolID 30 Character string
         * @param mod1I number
         * @return string
         */
        fun setCommonModifier1(symbolID: String, mod1I: Number): String

        /**
         * Get Sector 2 Modifier from positions 17-18.
         * @param symbolID 30 Character string
         * @return number
         */
        fun getModifier2(symbolID: String): Number

        /**
         * Set Sector 2 Modifier at positions 17-18.
         * @param symbolID 30 Character string
         * @param mod1 number
         * @return string
         */
        fun setModifier2(symbolID: String, mod1: Number): String

        /**
         * Get Common Sector 2 Modifier from position 22.
         * @param symbolID 30 Character string
         * @return number
         */
        fun getCommonModifier2(symbolID: String): Number

        /**
         * Set Common Sector 2 Modifier at position 22.
         * @param symbolID 30 Character string
         * @param mod1I number
         * @return string
         */
        fun setCommonModifier2(symbolID: String, mod1I: Number): String

        /**
         * Returns true is symbol is of the Meteorological variety.
         * @param symbolID 30 Character string
         * @return boolean
         * @deprecated See {@link SymbolUtilities.isWeather()}
         */
        fun isMETOC(symbolID: String): Boolean

        /**
         * Build string to grab appropriate SVG file
         * @param symbolID 30 Character string
         * @return string
         * @deprecated See {@link SVGLookup.getFrameID()}
         */
        fun getFrameID(symbolID: String): String

        /**
         * Build string to grab appropriate SVG file
         * @param symbolID 30 Character string
         * @return string
         * @deprecated See {@link SVGLookup.getMainIconID()}
         */
        fun getMainIconID(symbolID: String): String

        /**
         * Build string to grab appropriate SVG file
         * @param symbolID 30 Character string
         * @return string
         * @deprecated See {@link SVGLookup.getMod2ID()} (String)}
         */
        fun getMod2ID(symbolID: String): String

        /**
         * Build string to grab appropriate SVG file
         * @param symbolID 30 Character string
         * @return string
         * @deprecated See {@link SVGLookup.getMod1ID()} (String)}
         */
        fun getMod1ID(symbolID: String): String

        /**
         * Gets the 3 digit county code from positions 28-30
         * @param symbolID 30 Character string
         * @return number
         */
        fun getCountryCode(symbolID: String): Number

        /**
         * In 2525E, position 23 of the symbol code has the Frame Shape modifier.
         * This lets a user force a different frame shape than what a symbol would normally have.
         * Like you could have Air Fixed Wing with a ground unit rectangle frame for when it's on the ground.
         * This function returns the frame shape value for what the default frame would be for a specific symbol set.
         * @param symbolID 30 Character string
         * @return string (1 character)
         */
        fun getDefaultFrameShape(symbolID: String): String

        /**
         * Gets the Frame Shape override from position 23.
         * @param symbolID 30 Character string
         * @return string (1 character)
         */
        fun getFrameShape(symbolID: String): String
    }
}

external class AffineTransform {
    constructor ()
}

external class PathIterator {
    constructor (tx: AffineTransform?)

    fun getPoints(): Array<POINT2>
    fun currentSegment(coords: JsReadonlyArray<Number>): int
    fun getWindingRule(): int
    fun isDone(): Boolean
    fun next(): Unit
    fun reset(): Unit
    fun moveTo(x: double, y: double): Unit
    fun lineTo(x: double, y: double): Unit
    fun cubicTo(x1: double, y1: double, x2: double, y2: double, x3: double, y3: double): Unit
    fun curveTo(x1: double, y1: double, x2: double, y2: double, x3: double, y3: double): Unit
    fun quadTo(x1: double, y1: double, x2: double, y2: double): Unit
    fun getBounds(): Rectangle2D
    fun setPathIterator(pts: Array<POINT2>): Unit

    companion object {
        val SEG_CLOSE: int
        val SEG_CUBICTO: int
        val SEG_LINETO: int
        val SEG_MOVETO: int
        val SEG_QUADTO: int
        val WIND_EVEN_ODD: int
        val WIND_NON_ZERO: int
    }
}

/**
 *
 *
 */
external interface Shape {
    fun contains(x: int, y: int): Boolean
    fun contains(x: int, y: int, width: int, height: int): Boolean
    fun contains(pt: Point2D): Boolean
    fun getBounds2D(): Rectangle2D
    fun getBounds(): Rectangle
    fun intersects(x: double, y: double, w: double, h: double): Boolean
    fun intersects(rect: Rectangle2D): Boolean
    fun getPathIterator(at: AffineTransform?): PathIterator
}

external class Rectangle : Shape {
    constructor ()
    constructor (x1: int, y1: int, width1: int, height1: int)

    var x: int
    var y: int
    var width: int
    var height: int
    fun getShapeType(): String
    override fun getBounds(): Rectangle
    override fun getPathIterator(at: AffineTransform?): PathIterator
    override fun intersects(rect: Rectangle2D): Boolean
    override fun intersects(x: double, y: double, w: double, h: double): Boolean
    override fun contains(pt: Point2D): Boolean
    override fun contains(x: int, y: int): Boolean
    override fun contains(x: int, y: int, width: int, height: int): Boolean
    override fun getBounds2D(): Rectangle2D
    fun getX(): double
    fun getY(): int
    fun getMinX(): int
    fun getMinY(): int
    fun getMaxX(): int
    fun getMaxY(): int
    fun getHeight(): int
    fun getWidth(): int
    fun getBottom(): Number
    fun getRight(): Number
    fun getCenterX(): Number

    /**
     *
     * @returns {Number}
     */
    fun getCenterY(): Number
    fun grow(h: int, v: int): Unit
    fun setRect(rect: Rectangle): Unit

    /**
     * setLocation x,y (top,left) while maintaining the width and height.
     * @param x
     * @param y
     */
    fun setLocation(x: Number, y: Number): Unit
    fun isEmpty(): Boolean
    fun shift(x: Number, y: Number): Unit

    /**
     * moves top,left points leaving bottom,right intact.
     * adjusts the height & width values as necessary
     * @param x
     * @param y
     */
    fun shiftTL(x: Number, y: Number): Unit

    /**
     * moves bottom,right points leaving top,left intact.
     * adjusts the height & width values as necessary
     * @param {type} x the amount to move the right point by
     * @param {type} y the amount to move the bottom point by
     * @returns {_L7.Anonym$0.Rectangle.shiftTL}
     */
    fun shiftBR(x: Number, y: Number): Unit

    /**
     * Will merge the bounds of two rectangle.
     * @param rect
     */
    fun union(rect: Rectangle): Unit
    fun unionPoint(point: Point): Unit

    /**
     *
     * @param point
     * @returns
     */
    fun containsPoint(point: Point): Boolean
    fun containsRectangle(rect: Rectangle): Boolean

    /**
     * Tests if the specified line segment intersects the interior of this
     * <code>Rectangle</code>. Ported from java.
     *
     * @param x1 the X coordinate of the start point of the specified
     *           line segment
     * @param y1 the Y coordinate of the start point of the specified
     *           line segment
     * @param x2 the X coordinate of the end point of the specified
     *           line segment
     * @param y2 the Y coordinate of the end point of the specified
     *           line segment
     * @return <code>true</code> if the specified line segment intersects
     * the interior of this <code>Rectangle</code>; <code>false</code>
     * otherwise.
     */
    fun intersectsLine(x1: Number, y1: Number, x2: Number, y2: Number): Boolean
    fun setPath(context: CanvasRenderingContext2D): Unit
    fun stroke(context: CanvasRenderingContext2D): Unit
    fun fill(context: CanvasRenderingContext2D): Unit
    fun clone(): Rectangle
    /**
     * ported from java
     */
    /**
     *
     * @param stroke named color or value of rgb(#,#,#)
     * @param strokeWidth width of line in # of pixels
     * @param fill named color or value of rgb(#,#,#)
     * @returns
     */
    fun toSVGElement(stroke: String?, strokeWidth: Number, fill: String?): String

    companion object {
        val OUT_LEFT: Any? /* type isn't declared */
        val OUT_TOP: Any? /* type isn't declared */
        val OUT_RIGHT: Any? /* type isn't declared */
        val OUT_BOTTOM: Any? /* type isn't declared */
    }
}

external class Polygon {
    constructor ()

    /**
     *
     * @param xpoints
     * @param ypoints
     * @param npoints
     */
    constructor (xpoints: JsReadonlyArray<int>, ypoints: JsReadonlyArray<int>, npoints: int)

    var npoints: int
    var xpoints: JsReadonlyArray<int>
    var ypoints: JsReadonlyArray<int>
    var bounds: Rectangle
    fun reset(): Unit
    fun invalidate(): Unit
    fun addPoint(px: int, py: int): Unit
    fun getBounds(): Rectangle
    fun getBoundingBox(): Rectangle
    fun contains(p: Point): Boolean

    fun contains(p: Point2D): Boolean
    fun contains(r: Rectangle2D): Boolean
    fun contains(x: double, y: double): Boolean
    fun contains(x: double, y: double, w: double, h: double): Boolean
    fun getBounds2D(): Nothing?
    fun intersects(r: Rectangle2D): Boolean
    fun intersects(x: double, y: double, w: double, h: double): Boolean
    fun getPathIterator(at: AffineTransform?): PathIterator
    fun getPathIterator(at: AffineTransform, flatness: double): PathIterator
}

/**
 *
 *
 */
external interface Stroke {
    fun createStrokedShape(s: Shape): Shape
}

external class BasicStroke : Stroke {
    /**
     * Constructs a new <code>BasicStroke</code> with defaults for all
     * attributes. The default attributes are a solid line of width 1.0,
     * CAP_SQUARE, JOIN_MITER, a miter limit of 10.0.
     */
    constructor ()

    /**
     * Constructs a solid <code>BasicStroke</code> with the specified line width
     * and with default values for the cap and join styles.
     *
     * @param width
     * the width of the <code>BasicStroke</code>
     * @throws IllegalArgumentException
     * if <code>width</code> is negative
     */
    constructor (width: float)
    constructor (width: float, cap: int, join: int)
    constructor (width: float, cap: int, join: int, miterlimit: float)
    constructor (
        width: float,
        cap: int,
        join: int,
        miterlimit: float,
        dash: JsReadonlyArray<float>?,
        dash_phase: float
    )

    var width: float
    var join: int
    var cap: int
    var miterlimit: float
    var dash: JsReadonlyArray<float>?
    var dash_phase: float

    /**
     * Returns a <code>Shape</code> whose interior defines the stroked outline
     * of a specified <code>Shape</code>.
     *
     * @param s
     * the <code>Shape</code> boundary be stroked
     * @return the <code>Shape</code> of the stroked outline.
     */
    override fun createStrokedShape(s: Shape): Shape
    fun getLineWidth(): float

    /**
     * Returns the end cap style.
     *
     * @return the end cap style of this <code>BasicStroke</code> as one of the
     * static <code>int</code> values that define possible end cap
     * styles.
     */
    fun getEndCap(): int
    fun getLineJoin(): int

    /**
     * Returns the limit of miter joins.
     *
     * @return the limit of miter joins of the <code>BasicStroke</code>.
     */
    fun getMiterLimit(): float

    /**
     * Returns the array representing the lengths of the dash segments.
     * Alternate entries in the array represent the user space lengths of the
     * opaque and transparent segments of the dashes. As the pen moves along the
     * outline of the <code>Shape</code> to be stroked, the user space distance
     * that the pen travels is accumulated. The distance value is used to index
     * into the dash array. The pen is opaque when its current cumulative
     * distance maps to an even element of the dash array and transparent
     * otherwise.
     *
     * @return the dash array.
     */
    fun getDashArray(): JsReadonlyArray<Number>?
    fun getDashPhase(): float

    companion object {
        /**
         * Joins path segments by extending their outside edges until they meet.
         */
        val JOIN_MITER: int

        /**
         * Joins path segments by rounding off the corner at a radius of half the
         * line width.
         */
        val JOIN_ROUND: int

        /**
         * Joins path segments by connecting the outer corners of their wide
         * outlines with a straight segment.
         */
        val JOIN_BEVEL: int

        /**
         * Ends unclosed subpaths and dash segments with no added decoration.
         */
        val CAP_BUTT: int

        /**
         * Ends unclosed subpaths and dash segments with a round decoration that has
         * a radius equal to half of the width of the pen.
         */
        val CAP_ROUND: int

        /**
         * Ends unclosed subpaths and dash segments with a square projection that
         * extends beyond the end of the segment to a distance equal to half of the
         * line width.
         */
        val CAP_SQUARE: int
        fun GetInteriorPoints(
            pLinePoints: JsReadonlyArray<POINT2>,
            vblCounter: int,
            lineType: int,
            dist: double
        ): Array<POINT2>
    }
}

external class FontRenderContext {
    constructor ()
}

external class TextLayout {
    constructor (s: String, font: Font, frc: FontRenderContext)

    var _font: Font
    var _str: String
    fun getOutline(tx: AffineTransform?): Shape
    fun getPixelBounds(frc: FontRenderContext, x: float, y: float): Nothing?
    fun getBounds(): Rectangle
}

external class TexturePaint {
    constructor (bi: ImageBitmap, rect: Rectangle2D?)
}

/**
 * Holds information on how to draw the pieces of a multipoint symbol.
 * Can be retrieved from {@link MilStdSymbol#getSymbolShapes()} and
 * {@link MilStdSymbol#getModifierShapes()} after {@link armyc2.c5isr.web.render.WebRenderer#RenderMultiPointAsMilStdSymbol(String, String, String, String, String, String, double, String, Map, Map)} is called.
 */
open external class ShapeInfo {
    constructor ()
    constructor (shape: Shape)

    /**
     *
     * @param shape
     * @param shapeType
     * ShapeInfo.SHAPE_TYPE_
     */
    constructor (shape: Shape, shapeType: int)
    constructor (textLayout: TextLayout, position: Point2D)

    var _Shape: Shape
    fun getShape(): Shape
    fun setShape(value: Shape): Unit
    fun getTextLayout(): TextLayout
    fun setTextLayout(value: TextLayout): Unit
    fun setModifierString(value: String): Unit
    fun getModifierString(): String
    fun setModifierPosition(value: Point2D): Unit
    fun getModifierPosition(): Point2D?
    fun setModifierAngle(value: double): Unit
    fun getModifierAngle(): double

    /**
     *
     * @deprecated use {@link setModifierPosition()}
     */
    fun setModifierStringPosition(value: Point2D): Unit

    /**
     *
     * @deprecated use {@link getModifierPosition()}
     */
    fun getModifierStringPosition(): Point2D

    /**
     *
     * @deprecated use {@link setModifierAngle()}
     */
    fun setModifierStringAngle(value: double): Unit

    /**
     *
     * @deprecated use {@link getModifierAngle()}
     */
    fun getModifierStringAngle(): double
    fun setModifierImage(value: SVGSymbolInfo): Unit
    fun getModifierImage(): String
    fun getModifierImageInfo(): SVGSymbolInfo

    /**
     * Object that can be used to store anything.
     * Will not be looked at when rendering.
     * Null by default
     * @param value
     */
    fun setTag(value: Any?): Unit

    /**
     * Object that can be used to store anything.
     * Will not be looked at when rendering.
     * Null by default
     * @return
     */
    fun getTag(): Any?

    /**
     * Gets bounds for the shapes.  Incorporates AffineTransform if not null
     * in the ShapeInfo object.
     * @return
     */
    open fun getBounds(): Rectangle?

    /**
     * needed to draw Glyphs and TextLayouts
     * @param position
     */
    fun setGlyphPosition(position: Point): Unit

    /**
     * needed to draw Glyphs and TextLayouts
     * @param position
     */
    fun setGlyphPosition(position: Point2D): Unit

    /**
     * needed to draw Glyphs and TextLayouts
     * @return
     */
    fun getGlyphPosition(): Point2D?
    fun setLineColor(value: Color?): Unit
    fun getLineColor(): Color?
    fun setFillColor(value: Color?): Unit
    fun getFillColor(): Color?
    fun setTextBackgroundColor(value: Color): Unit
    fun getTextBackgroundColor(): Color
    fun getStroke(): BasicStroke

    /**
     * @deprecated
     */
    fun getTexturePaint(): TexturePaint?

    /**
     * @deprecated
     */
    fun setTexturePaint(value: TexturePaint?): Unit
    fun getFillStyle(): int
    fun setFillStyle(value: int): Unit
    fun setStroke(s: BasicStroke): Unit

    /**
     * For Internal Renderer use
     * @param value
     * ShapeInfo.SHAPE_TYPE_
     *
     */
    fun setShapeType(value: int): Unit

    /**
     * For Internal Renderer use
     * @return ShapeInfo.SHAPE_TYPE_
     *
     */
    fun getShapeType(): int
    fun getPolylines(): Array<Array<Point2D>>
    fun setPolylines(value: Array<Array<Point2D>>): Unit

    /**
     * @deprecated
     */
    fun setShader(value: ImageBitmap): Unit

    /**
     * @deprecated
     */
    fun getShader(): ImageBitmap
    fun setPatternFillImage(img: SVGSymbolInfo): Unit
    fun getPatternFillImage(): String?
    fun getPatternFillImageInfo(): SVGSymbolInfo?
    fun getTextJustify(): int
    fun setTextJustify(value: int): Unit

    companion object {
        var SHAPE_TYPE_POLYLINE: int
        var SHAPE_TYPE_FILL: int
        var SHAPE_TYPE_MODIFIER: int
        var SHAPE_TYPE_MODIFIER_FILL: int
        var SHAPE_TYPE_UNIT_FRAME: int
        var SHAPE_TYPE_UNIT_FILL: int
        var SHAPE_TYPE_UNIT_SYMBOL1: int
        var SHAPE_TYPE_UNIT_SYMBOL2: int
        var SHAPE_TYPE_UNIT_DISPLAY_MODIFIER: int
        var SHAPE_TYPE_UNIT_ECHELON: int
        var SHAPE_TYPE_UNIT_AFFILIATION_MODIFIER: int
        var SHAPE_TYPE_UNIT_HQ_STAFF: int
        var SHAPE_TYPE_TG_SP_FILL: int
        var SHAPE_TYPE_TG_SP_FRAME: int
        var SHAPE_TYPE_TG_Q_MODIFIER: int
        var SHAPE_TYPE_TG_SP_OUTLINE: int
        var SHAPE_TYPE_SINGLE_POINT_OUTLINE: int
        var SHAPE_TYPE_UNIT_OUTLINE: int
        var SHAPE_TYPE_UNIT_OPERATIONAL_CONDITION: int
        var justify_left: int
        var justify_center: int
        var justify_right: int
    }
}

external class DistanceUnit {
    constructor (conversionFactor: double, label: String)

    val conversionFactor: double
    val label: String
    fun toAttribute(): String

    companion object {
        fun parse(distanceUnitText: String?): DistanceUnit?
        var METERS: DistanceUnit
        var FEET: DistanceUnit
        var FLIGHT_LEVEL: DistanceUnit
    }
}

/**
 * Object that holds information on how to draw a multipoint symbol after {@link armyc2.c5isr.web.render.WebRenderer#RenderMultiPointAsMilStdSymbol(String, String, String, String, String, String, double, String, Map, Map)}  is called.
 */
external class MilStdSymbol {
    /**
     *
     * @param symbolID code, 20-30 digits long that represents the symbol
     * @param uniqueID for the client's use
     * @param modifiers use keys from Modifiers.
     * @param Coordinates {@link ArrayList} of {@link Point2D} coordinates for the symbol
     * @param keepUnitRatio - default TRUE
     * modifiers
     */
    constructor (
        symbolID: String,
        uniqueID: String?,
        Coordinates: Array<Point2D>,
        modifiers: Map<String, String>?,
        keepUnitRatio: Boolean = definedExternally
    )

    var _LineWidth: Number
    var _LineColor: Color
    var _FillColor: Color
    var _TextColor: Color
    var _TextBackgroundColor: Color
    var _Rotation: double
    var _Outline: Boolean
    var _OutLineColor: Color
    var _OutLineWidth: int
    var _tp: TexturePaint
    var _fs: Boolean
    var _patternFillType: int
    var _Tag: Any?
    fun getFillStyle(): TexturePaint
    fun setFillStyle(value: TexturePaint): Unit
    fun getUseFillPattern(): Boolean
    fun setUseFillPattern(value: Boolean): Unit

    /**
     * @deprecated
     */
    fun getPatternFillType(): int

    /**
     * 0=Solid, 2=ForwardHatch, 3=BackwardHatch, 4=verticalHatch, 5=horizonalHatch, 8=CrossHatch
     * Only affects Basic Shapes.  Will not apply to MilStd Symbology so as to not confuse some
     * symbols with others.
     * @param value {@link Integer}
     *
     * @deprecated
     */
    fun setPatternFillType(value: int): Unit
    fun getAltitudeMode(): String
    fun setAltitudeMode(value: String): Unit
    fun getAltitudeUnit(): DistanceUnit
    fun setAltitudeUnit(unit: DistanceUnit): Unit
    fun getDistanceUnit(): DistanceUnit
    fun setDistanceUnit(unit: DistanceUnit): Unit
    fun getUseDashArray(): Boolean
    fun setUseDashArray(value: Boolean): Unit
    fun getHideOptionalLabels(): Boolean
    fun setHideOptionalLabels(value: Boolean): Unit
    fun setUseLineInterpolation(value: Boolean): Unit
    fun getUseLineInterpolation(): Boolean
    fun setUnitSize(pixelSize: int): Unit
    fun getUnitSize(): int
    fun setKeepUnitRatio(value: Boolean): Unit
    fun getKeepUnitRatio(): Boolean

    /**
     * Determines how to draw the Affiliation Modifier. True to draw as modifier
     * label in the "E/F" location. False to draw at the top right corner of the
     * symbol
     * @param value {@link Boolean}
     *
     * @deprecated
     */
    fun setDrawAffiliationModifierAsLabel(value: Boolean): Unit

    /**
     * True to draw as modifier label in the "E/F" location. False to draw at
     * the top right corner of the symbol
     * @return {@link Boolean}
     *
     * @deprecated
     */
    fun getDrawAffiliationModifierAsLabel(): Boolean

    /**
     * Returns the modifier map for the symbol
     * @return {@link Map}
     */
    fun getModifierMap(): JsReadonlyMap<String, String>

    /**
     * sets the modifier map for the symbol
     * @param modifiers {@link Map}
     */
    fun setModifierMap(modifiers: JsReadonlyMap<String, String>): Unit

    /**
     * Get a modifier value
     * @param modifier {@link Modifiers}
     * @return {@link String}
     */
    fun getModifier(modifier: String): String

    /**
     * Gets modifier value based on modifier constant and index in array
     * @param modifier {@link Modifiers}
     * @param index {@link Integer} array location, only applicable to AM, AN and X
     * @return {@link String}
     */
    fun getModifier(modifier: String, index: int): String

    /**
     * Set a modifier value
     * @param modifier {@link Modifiers}
     * @param value {@link String}
     */
    fun setModifier(modifier: String, value: String): Unit

    /**
     * Modifiers must be added in order. No setting index 2 without first
     * setting index 0 and 1. If setting out of order is attempted, the value
     * will just be added to the end of the list.
     *
     * @param modifier {@link Modifiers}
     * @param value {@link String}
     * @param index {@link Integer}
     */
    fun setModifier(modifier: String, value: String, index: int): Unit

    /**
     * Get modifier value for AM, AN or X
     * @param modifier {@link Modifiers}
     * @param index {@link Integer} array location
     * @return {@link Number}
     */
    fun getModifier_AM_AN_X(modifier: String, index: int): String?
    fun setModifier_AM_AN_X(modifier: String, value: Number, index: int): Unit
    fun getModifiers_AM_AN_X(modifier: String): Array<Number>?
    fun setModifiers_AM_AN_X(modifier: String, modifiers: Array<Number>): Unit

    /**
     *
     * @param value {@link Color}
     */
    fun setFillColor(value: Color): Unit

    /**
     *
     * @return {@link Color}
     */
    fun getFillColor(): Color

    /**
     *
     * @param value {@link Color}
     */
    fun setTextColor(value: Color): Unit

    /**
     *
     * @return {@link Color}
     */
    fun getTextColor(): Color

    /**
     *
     * @param value {@link Color}
     */
    fun setTextBackgroundColor(value: Color): Unit

    /**
     *
     * @return {@link Color}
     */
    fun getTextBackgroundColor(): Color

    /**
     *
     * @param value {@link Integer}
     */
    fun setLineWidth(value: int): Unit

    /**
     *
     * @return {@link Integer}
     */
    fun getLineWidth(): int

    /**
     * If value is null or SymbolUtilities.isGreenProtectionGraphic() is true then value is ignored
     *
     * @param value {@link Color}
     */
    fun setLineColor(value: Color?): Unit

    /**
     *
     * @return {@link Color}
     */
    fun getLineColor(): Color

    /**
     * if null, renderer will use white or black for the outline based on the color
     * of the symbol. Otherwise, it will used the passed color value.
     *
     * @param value {@link Color}
     */
    fun setOutlineColor(value: Color): Unit
    fun getOutlineColor(): Color

    /**
     * Extra value for client. defaults to null. Not used for rendering by
     * JavaRenderer
     *
     * @param value  {@link Object}
     * @deprecated
     */
    fun setTag(value: Any?): Unit

    /**
     * Extra value for client. defaults to null. Not used for rendering by
     * JavaRenderer
     *
     * @return {@link Object}
     * @deprecated
     */
    fun getTag(): Any?

    /**
     *
     * @param value {@link ArrayList}
     */
    fun setCoordinates(value: Array<Point2D>): Unit

    /**
     *
     * @return {@link ArrayList}
     */
    fun getCoordinates(): Array<Point2D>

    /**
     * Shapes that represent the symbol modifiers
     *
     * @param value ArrayList&lt;Shape&gt;
     */
    fun setModifierShapes(value: Array<ShapeInfo>): Unit

    /**
     * Shapes that represent the symbol modifiers
     *
     * @return {@link ArrayList}
     */
    fun getModifierShapes(): Array<ShapeInfo>

    /**
     * the java shapes that make up the symbol
     *
     * @param value ArrayList&lt;ShapeInfo&gt;
     */
    fun setSymbolShapes(value: Array<ShapeInfo>): Unit

    /**
     * the java shapes that make up the symbol
     *
     * @return {@link ArrayList}
     */
    fun getSymbolShapes(): Array<ShapeInfo>

    /**
     * The Symbol Id of the MilStdSymbol.
     *
     * @return {@link String}
     */
    fun getSymbolID(): String

    /**
     * Unique ID of the Symbol. For client use.
     *
     * @return {@link String}
     */
    fun getUUID(): String

    /**
     * Unique ID of the Symbol. For client use.
     *
     * @param ID {@link String}
     */
    fun setUUID(ID: String): Unit

    /**
     * Sets the Symbol ID for the symbol. Should be a 20-30 digit string from
     * the milstd.
     *
     * @param value {@link String}
     */
    fun setSymbolID(value: String): Unit
    fun set_WasClipped(value: Boolean): Unit
    fun get_WasClipped(): Boolean
}

/**
 * Interface for Point Conversion objects.  Recommend using the functions
 * that take and return Point2D objects.
 *
 */
external interface IPointConversion {
    fun PixelsToGeo(pixel: Point2D): Point2D
    fun GeoToPixels(coord: Point2D): Point2D
}

/**
 *
 *
 */
external class PointConverter3D : IPointConversion {
    constructor (controlLong: double, controlLat: double, scale: double)

    fun PixelsToGeo(pixel: Point): Point2D
    override fun PixelsToGeo(pixel: Point2D): Point2D
    override fun GeoToPixels(coord: Point2D): Point2D
}

external class FontMetrics {
    constructor (font: Font)

    var _fontRenderContext: FontRenderContext
    var _font: Font
    fun stringWidth(str: String): int
    fun getFontRenderContext(): FontRenderContext
}

external class Graphics2D {
    constructor ()

    fun setFont(value: Font): Unit
    fun getFont(): Font
    fun setFontMetrics(value: FontMetrics): Unit
    fun getFontMetrics(): FontMetrics
    fun setColor(color: Color): Unit
    fun setBackground(color: Color): Unit
    fun setTransform(id: AffineTransform): Unit
    fun getTransform(): Nothing?
    fun setStroke(stroke: BasicStroke): Unit
    fun drawLine(x1: double, y1: double, x2: double, y2: double): Unit
    fun dispose(): Unit
    fun rotate(theta: double, x: double, y: double): Unit
    fun clearRect(x: double, y: double, width: double, height: double): Unit
    fun drawString(s: String, x: double, y: double): Unit
    fun getFontRenderContext(): FontRenderContext
}

external class Shape2 : ShapeInfo {
    constructor (value: int)

    fun set_Style(value: int): Unit
    fun get_Style(): int
    fun lineTo(pt: POINT2): Unit
    fun moveTo(pt: POINT2): Unit
    override fun getBounds(): Rectangle
    fun getPoints(): Array<POINT2>
}

external class Modifier2 {
    constructor ()

    fun get_TextPath(): JsReadonlyArray<POINT2>
    fun set_TextPath(value: JsReadonlyArray<POINT2>): Unit
    fun set_IsIntegral(value: Boolean): Unit
    fun get_IsIntegral(): Boolean

    companion object {
        /**
         * Returns symbol MBR. Assumes points have been initialized with value of
         * 0th point
         *
         * @param tg the tactical graphic object
         * @param ptUl OUT - MBR upper left
         * @param ptUr OUT - MBR upper right
         * @param ptLr OUT - MBR lower right
         * @param ptLl OUT - MBR lower left
         */
        fun GetMBR(tg: TGLight, ptUl: POINT2, ptUr: POINT2, ptLr: POINT2, ptLl: POINT2): Unit

        /**
         * removes text modifiers for CPOF tactical areas which do not fit inside
         * the symbol MBR
         *
         * @param tg
         * @param g2d
         * @param isTextFlipped true if text is flipped from the last segment
         * orientation
         * @param iteration the instance count for this modifier
         */
        fun RemoveModifiers(tg: TGLight, g2d: Graphics2D, isTextFlipped: Boolean, iteration: int): Unit

        /**
         * Calculate modifiers identical to addModifiers except use geodesic
         * calculations for the center point.
         *
         * @param tg
         * @param g2d
         * @param clipBounds
         * @param converter
         */
        fun AddModifiersGeo(tg: TGLight, g2d: Graphics2D, clipBounds: Rectangle2D?, converter: IPointConversion): Unit

        /**
         * Calculate modifiers identical to addModifiers except use geodesic
         * calculations for the center point.
         *
         * @param tg
         * @param g2d
         * @param clipBounds
         * @param converter
         */
        fun AddModifiersGeo(
            tg: TGLight,
            g2d: Graphics2D,
            clipBounds: Array<Point2D>?,
            converter: IPointConversion
        ): Unit

        /**
         * Called by the renderer after tg.Pixels has been filled with the
         * calculated points. The modifier path depends on points calculated by
         * CELineArray.
         *
         * @param tg
         */
        fun AddModifiers2(tg: TGLight, converter: IPointConversion): Unit

        /**
         * Displays the tg modifiers using a client Graphics2D, this is an option
         * provided to clients for displaying modifiers without using shapes
         *
         * @param tg the tactical graphic
         * @param g2d the graphics object for drawing
         * @deprecated
         */
        fun DisplayModifiers(tg: TGLight, g2d: Graphics2D): Unit

        /**
         * Returns a Shape object for the text background for labels and modifiers
         *
         * @param tg the tactical graphic object
         * @param pt0 1st point of segment
         * @param pt1 last point of segment
         * @param stringWidth string width
         * @param stringHeight string height
         * @param lineFactor number of text lines above or below the segment
         * @param isTextFlipped true if text is flipped
         * @return the modifier shape
         */
        fun BuildModifierShape(
            tg: TGLight,
            pt0: POINT2,
            pt1: POINT2,
            stringWidth: int,
            stringHeight: int,
            lineFactor: double,
            isTextFlipped: Boolean
        ): Shape2

        /**
         * For BOUNDARY and other line types which require breaks for the integral
         * text. Currently only boundary uses this
         *
         * @param tg
         * @param g2d the graphics object for drawing
         * @param shapes the shape array
         */
        fun GetIntegralTextShapes(tg: TGLight, g2d: Graphics2D, shapes: Array<Shape2>): Unit

        /**
         * Displays the modifiers to a Graphics2D from a BufferedImage
         *
         * @param tg the tactical graphic
         * @param g2d the Graphic for drawing
         * @param shapes the shape array
         * @param isTextFlipped true if text is flipped
         * @param converter to convert between geographic and pixel coordinates
         */
        fun DisplayModifiers2(
            tg: TGLight,
            g2d: Graphics2D,
            shapes: Array<Shape2>,
            isTextFlipped: Boolean,
            converter: IPointConversion
        ): Unit

        /**
         * Builds a shape object to wrap text
         *
         * @param g2d the Graphic object for drawing
         * @param str text to wrap
         * @param font the draw font
         * @param tx the drawing transform, text rotation and translation
         * @return
         */
        fun getTextShape(g2d: Graphics2D, str: String, font: Font, tx: AffineTransform): Shape

        /**
         * Creates text outline as a shape
         *
         * @param originalText the original text
         * @return text shape
         */
        fun createTextOutline(originalText: Shape2): Shape2
    }
}

external class TGLight {
    constructor ()

    var LatLongs: Array<POINT2>
    fun get_LatLongs(): Array<POINT2>
    fun set_LatLongs(value: Array<POINT2>): Unit
    var Pixels: Array<POINT2>
    fun get_Pixels(): Array<POINT2>
    fun set_Pixels(value: Array<POINT2>): Unit
    var modifiers: Array<Modifier2>
    fun get_Modifiers(): Array<Modifier2>
    fun set_Modifiers(value: Array<Modifier2>): Unit
    var tp: TexturePaint
    fun set_TexturePaint(value: TexturePaint): Unit
    fun get_TexturePaint(): TexturePaint
    var maskOff: Boolean
    fun set_Font(value: Font): Unit
    fun get_Font(): Font

    /**
     * Set the icon size for areas that have a symbol like LAA or Biological Contaminated Area
     * @param pixelSize
     */
    fun setIconSize(pixelSize: int): Unit
    fun getIconSize(): int
    fun set_KeepUnitRatio(value: Boolean): Unit
    fun get_KeepUnitRation(): Boolean
    fun set_LineType(value: int): Unit
    fun get_LineType(): int
    fun set_LineStyle(value: int): Unit
    fun get_LineStyle(): int
    fun get_LineColor(): Color?
    fun set_LineColor(value: Color?): Unit
    fun get_FillStyle(): int
    fun set_Fillstyle(value: int): Unit
    fun get_FillColor(): Color?
    fun set_FillColor(value: Color?): Unit
    fun get_FontBackColor(): Color
    fun set_FontBackColor(value: Color): Unit
    fun get_TextColor(): Color
    fun set_TextColor(value: Color): Unit
    fun get_LineThickness(): int
    fun set_LineThickness(value: int): Unit
    fun get_Name(): String
    fun get_Client(): String
    fun set_client(value: String): Unit
    fun set_Name(value: String): Unit
    fun get_T1(): String
    fun set_T1(value: String): Unit
    fun get_AM(): String
    fun set_AM(value: String): Unit
    fun get_AM1(): String
    fun set_AM1(value: String): Unit
    fun get_AN(): String
    fun set_AN(value: String): Unit
    fun get_V(): String
    fun set_V(value: String): Unit
    fun get_AP(): String
    fun set_AP(value: String): Unit
    fun get_AS(): String
    fun set_AS(value: String): Unit
    fun get_X(): String
    fun set_X(value: String): Unit
    fun get_X1(): String
    fun set_X1(value: String): Unit
    fun get_H(): String
    fun set_H(value: String): Unit
    fun get_Location(): String
    fun set_Location(value: String): Unit

    /**
     * @deprecated
     */
    fun get_H1(): String

    /**
     * @deprecated
     */
    fun set_H1(value: String): Unit
    fun get_N(): String
    fun set_N(value: String): Unit

    /**
     * @deprecated
     */
    fun get_H2(): String

    /**
     * @deprecated
     */
    fun set_H2(value: String): Unit
    fun get_LRMM(): String
    fun set_LRMM(value: String): Unit
    fun get_DTG(): String
    fun set_DTG(value: String): Unit
    fun get_DTG1(): String
    fun set_DTG1(value: String): Unit
    fun get_StandardIdentity(): String

    /**
     * @return true if standard identity is suspect/joker or hostile/faker
     */
    fun isHostile(): Boolean
    fun get_EchelonSymbol(): String
    fun set_EchelonSymbol(value: String): Unit
    fun get_SymbolId(): String
    fun get_Status(): String
    fun set_Status(value: String): Unit

    /**
     * Sets tactical graphic properties based on the 20-30 digit Mil-Std-2525 symbol code
     *
     * @param value
     */
    fun set_SymbolId(value: String): Unit

    /**
     * @deprecated
     */
    fun set_VisibleModifiers(value: Boolean): Unit

    /**
     * @deprecated
     */
    fun get_VisibleModifiers(): Boolean

    /**
     * @deprecated
     */
    fun set_VisibleLabels(value: Boolean): Unit

    /**
     * @deprecated
     */
    fun get_VisibleLabels(): Boolean
    var _useLineInterpolation: Boolean
    fun get_UseLineInterpolation(): Boolean
    fun set_UseLineInterpolation(value: Boolean): Unit
    var _useDashArray: Boolean
    fun get_UseDashArray(): Boolean
    fun set_UseDashArray(value: Boolean): Unit
    var _useHatchFill: Boolean
    fun get_UseHatchFill(): Boolean
    fun set_UseHatchFill(value: Boolean): Unit
    fun set_WasClipped(value: Boolean): Unit
    fun get_WasClipped(): Boolean
    fun get_HideOptionalLabels(): Boolean
    fun set_HideOptionalLabels(value: Boolean): Unit
    fun set_lineCap(cap: int): Unit
    fun get_lineCap(): int
}

/**
 * Rendering class
 *
 *
 */
external class clsRenderer {

    companion object {
        /**
         * Create MilStdSymbol from tactical graphic
         *
         * @deprecated
         * @param tg tactical graphic
         * @param converter geographic to pixels to converter
         * @return MilstdSymbol object
         */
        fun createMilStdSymboFromTGLight(tg: TGLight, converter: IPointConversion): MilStdSymbol

        /**
         * Build a tactical graphic object from the client MilStdSymbol
         *
         * @param milStd MilstdSymbol object
         * @param converter geographic to pixels converter
         * @return tactical graphic
         */
        fun createTGLightFromMilStdSymbol(milStd: MilStdSymbol, converter: IPointConversion): TGLight

        /**
         * @deprecated @param milStd
         * @param converter
         * @param computeChannelPt
         * @return
         */
        fun createTGLightFromMilStdSymbol(
            milStd: MilStdSymbol,
            converter: IPointConversion,
            computeChannelPt: Boolean
        ): TGLight

        /**
         * Added function to handle when coords or display area spans IDL but not
         * both, it prevents the symbol from rendering if the bounding rectangles
         * don't intersect.
         *
         * @param tg
         * @param converter
         * @param clipArea
         * @return
         */
        fun intersectsClipArea(
            tg: TGLight,
            converter: IPointConversion,
            clipArea: JsReadonlyArray<Point2D>
        ): Boolean

        /**
         * Added function to handle when coords or display area spans IDL but not
         * both, it prevents the symbol from rendering if the bounding rectangles
         * don't intersect.
         *
         * @param tg
         * @param converter
         * @param clipArea
         * @return
         */
        fun intersectsClipArea(tg: TGLight, converter: IPointConversion, clipArea: Rectangle): Boolean

        /**
         * Added function to handle when coords or display area spans IDL but not
         * both, it prevents the symbol from rendering if the bounding rectangles
         * don't intersect.
         *
         * @param tg
         * @param converter
         * @param clipArea
         * @return
         */
        fun intersectsClipArea(tg: TGLight, converter: IPointConversion, clipArea: Rectangle2D): Boolean

        /**
         * GoogleEarth renderer uses polylines for rendering
         *
         * @param mss MilStdSymbol object
         * @param converter the geographic to pixels coordinate converter
         * @param clipArea the clip bounds
         */
        fun renderWithPolylines(
            mss: MilStdSymbol,
            converter: IPointConversion,
            clipArea: JsReadonlyArray<Point2D>?
        ): Unit

        /**
         * GoogleEarth renderer uses polylines for rendering
         *
         * @param mss MilStdSymbol object
         * @param converter the geographic to pixels coordinate converter
         * @param clipArea the clip bounds
         */
        fun renderWithPolylines(mss: MilStdSymbol, converter: IPointConversion, clipArea: Rectangle?): Unit

        /**
         * GoogleEarth renderer uses polylines for rendering
         *
         * @param mss MilStdSymbol object
         * @param converter the geographic to pixels coordinate converter
         * @param clipArea the clip bounds
         */
        fun renderWithPolylines(mss: MilStdSymbol, converter: IPointConversion, clipArea: Rectangle2D?): Unit

        /**
         * @param mss
         * @param converter
         * @param clipArea
         * @param g2d
         * @deprecated Graphics2D not used
         */
        fun renderWithPolylines(
            mss: MilStdSymbol,
            converter: IPointConversion,
            clipArea: JsReadonlyArray<Point2D>,
            g2d: Graphics2D
        ): Unit

        /**
         * @param mss
         * @param converter
         * @param clipArea
         * @param g2d
         * @deprecated Graphics2D not used
         */
        fun renderWithPolylines(
            mss: MilStdSymbol,
            converter: IPointConversion,
            clipArea: Rectangle,
            g2d: Graphics2D
        ): Unit

        /**
         * @param mss
         * @param converter
         * @param clipArea
         * @param g2d
         * @deprecated Graphics2D not used
         */
        fun renderWithPolylines(
            mss: MilStdSymbol,
            converter: IPointConversion,
            clipArea: Rectangle2D,
            g2d: Graphics2D
        ): Unit

        /**
         * Google Earth renderer: Called by mapfragment-demo This is the public
         * interface for Google Earth renderer assumes tg.Pixels is filled assumes
         * the caller instantiated the ShapeInfo arrays
         *
         * @param tg tactical graphic
         * @param shapeInfos symbol ShapeInfo array
         * @param modifierShapeInfos modifier ShapeInfo array
         * @param converter geographic to pixels coordinate converter
         * @param clipArea clipping bounds in pixels
         */
        fun render_GE(
            tg: TGLight,
            shapeInfos: Array<ShapeInfo>,
            modifierShapeInfos: Array<ShapeInfo>,
            converter: IPointConversion,
            clipArea: JsReadonlyArray<Point2D>
        ): Unit

        /**
         * Google Earth renderer: Called by mapfragment-demo This is the public
         * interface for Google Earth renderer assumes tg.Pixels is filled assumes
         * the caller instantiated the ShapeInfo arrays
         *
         * @param tg tactical graphic
         * @param shapeInfos symbol ShapeInfo array
         * @param modifierShapeInfos modifier ShapeInfo array
         * @param converter geographic to pixels coordinate converter
         * @param clipArea clipping bounds in pixels
         */
        fun render_GE(
            tg: TGLight,
            shapeInfos: Array<ShapeInfo>,
            modifierShapeInfos: Array<ShapeInfo>,
            converter: IPointConversion,
            clipArea: Rectangle
        ): Unit

        /**
         * Google Earth renderer: Called by mapfragment-demo This is the public
         * interface for Google Earth renderer assumes tg.Pixels is filled assumes
         * the caller instantiated the ShapeInfo arrays
         *
         * @param tg tactical graphic
         * @param shapeInfos symbol ShapeInfo array
         * @param modifierShapeInfos modifier ShapeInfo array
         * @param converter geographic to pixels coordinate converter
         * @param clipArea clipping bounds in pixels
         */
        fun render_GE(
            tg: TGLight,
            shapeInfos: Array<ShapeInfo>,
            modifierShapeInfos: Array<ShapeInfo>,
            converter: IPointConversion,
            clipArea: Rectangle2D
        ): Unit

        /**
         * See render_GE below for comments
         *
         * @param tg
         * @param shapeInfos
         * @param modifierShapeInfos
         * @param converter
         * @param clipArea
         * @param g2d test android-gradle
         * @deprecated Graphics2D not used
         */
        fun render_GE(
            tg: TGLight,
            shapeInfos: Array<ShapeInfo>,
            modifierShapeInfos: Array<ShapeInfo>,
            converter: IPointConversion,
            clipArea: JsReadonlyArray<Point2D>,
            g2d: Graphics2D
        ): Unit

        /**
         * See render_GE below for comments
         *
         * @param tg
         * @param shapeInfos
         * @param modifierShapeInfos
         * @param converter
         * @param clipArea
         * @param g2d test android-gradle
         * @deprecated Graphics2D not used
         */
        fun render_GE(
            tg: TGLight,
            shapeInfos: Array<ShapeInfo>,
            modifierShapeInfos: Array<ShapeInfo>,
            converter: IPointConversion,
            clipArea: Rectangle,
            g2d: Graphics2D
        ): Unit

        /**
         * See render_GE below for comments
         *
         * @param tg
         * @param shapeInfos
         * @param modifierShapeInfos
         * @param converter
         * @param clipArea
         * @param g2d test android-gradle
         * @deprecated Graphics2D not used
         */
        fun render_GE(
            tg: TGLight,
            shapeInfos: Array<ShapeInfo>,
            modifierShapeInfos: Array<ShapeInfo>,
            converter: IPointConversion,
            clipArea: Rectangle2D,
            g2d: Graphics2D
        ): Unit

        /**
         * creates a shape for known symbols. The intent is to use client points for
         * the shape and is intended for use with ellipse. If hatch &gt; 1 it creates 2 shapes
         * one for the hatch pattern, the second one is for the outline.
         *
         * @param milStd
         * @param ipc
         * @param clipArea
         * @param shapeType
         * @param lineColor
         * @param fillColor
         * @param hatch
         */
        fun render_Shape(
            milStd: MilStdSymbol,
            ipc: IPointConversion,
            clipArea: JsReadonlyArray<Point2D>,
            shapeType: int,
            lineColor: Color,
            fillColor: Color,
            hatch: int
        ): Unit

        /**
         * creates a shape for known symbols. The intent is to use client points for
         * the shape and is intended for use with ellipse. If hatch &gt; 1 it creates 2 shapes
         * one for the hatch pattern, the second one is for the outline.
         *
         * @param milStd
         * @param ipc
         * @param clipArea
         * @param shapeType
         * @param lineColor
         * @param fillColor
         * @param hatch
         */
        fun render_Shape(
            milStd: MilStdSymbol,
            ipc: IPointConversion,
            clipArea: Rectangle,
            shapeType: int,
            lineColor: Color,
            fillColor: Color,
            hatch: int
        ): Unit

        /**
         * creates a shape for known symbols. The intent is to use client points for
         * the shape and is intended for use with ellipse. If hatch &gt; 1 it creates 2 shapes
         * one for the hatch pattern, the second one is for the outline.
         *
         * @param milStd
         * @param ipc
         * @param clipArea
         * @param shapeType
         * @param lineColor
         * @param fillColor
         * @param hatch
         */
        fun render_Shape(
            milStd: MilStdSymbol,
            ipc: IPointConversion,
            clipArea: Rectangle2D,
            shapeType: int,
            lineColor: Color,
            fillColor: Color,
            hatch: int
        ): Unit

        /**
         * public render function transferred from JavaLineArrayCPOF project. Use
         * this function to replicate CPOF renderer functionality.
         *
         * @param mss the milStdSymbol object
         * @param converter the geographic to pixels coordinate converter
         * @param clipBounds the pixels based clip bounds
         */
        fun render(mss: MilStdSymbol, converter: IPointConversion, clipBounds: Rectangle2D?): Unit

        /**
         * public render function transferred from JavaLineArrayCPOF project. Use
         * this function to replicate CPOF renderer functionality.
         *
         * @param mss the milStdSymbol object
         * @param converter the geographic to pixels coordinate converter
         * @param clipBounds the pixels based clip bounds
         */
        fun render(mss: MilStdSymbol, converter: IPointConversion, clipBounds: Array<Point2D>?): Unit

        /**
         * Generic tester button says Tiger or use JavaRendererSample. Generic
         * renderer testers: called by JavaRendererSample and TestJavaLineArray
         * public render function transferred from JavaLineArrayCPOF project. Use
         * this function to replicate CPOF renderer functionality.
         *
         * @param mss MilStdSymbol
         * @param converter geographic to pixels converter
         * @param shapeInfos ShapeInfo array
         * @param modifierShapeInfos modifier ShapeInfo array
         * @param clipBounds clip bounds
         */
        fun render(
            mss: MilStdSymbol,
            converter: IPointConversion,
            shapeInfos: Array<ShapeInfo>,
            modifierShapeInfos: Array<ShapeInfo>,
            clipBounds: Rectangle2D?
        ): Unit

        /**
         * Generic tester button says Tiger or use JavaRendererSample. Generic
         * renderer testers: called by JavaRendererSample and TestJavaLineArray
         * public render function transferred from JavaLineArrayCPOF project. Use
         * this function to replicate CPOF renderer functionality.
         *
         * @param mss MilStdSymbol
         * @param converter geographic to pixels converter
         * @param shapeInfos ShapeInfo array
         * @param modifierShapeInfos modifier ShapeInfo array
         * @param clipBounds clip bounds
         */
        fun render(
            mss: MilStdSymbol,
            converter: IPointConversion,
            shapeInfos: Array<ShapeInfo>,
            modifierShapeInfos: Array<ShapeInfo>,
            clipBounds: Rectangle?
        ): Unit

        /**
         * Generic tester button says Tiger or use JavaRendererSample. Generic
         * renderer testers: called by JavaRendererSample and TestJavaLineArray
         * public render function transferred from JavaLineArrayCPOF project. Use
         * this function to replicate CPOF renderer functionality.
         *
         * @param mss MilStdSymbol
         * @param converter geographic to pixels converter
         * @param shapeInfos ShapeInfo array
         * @param modifierShapeInfos modifier ShapeInfo array
         * @param clipBounds clip bounds
         */
        fun render(
            mss: MilStdSymbol,
            converter: IPointConversion,
            shapeInfos: Array<ShapeInfo>,
            modifierShapeInfos: Array<ShapeInfo>,
            clipBounds: Array<Point2D>?
        ): Unit

        fun getCMLineType(version: int, entityCode: int): int
    }
}

external class RendererUtilities {

    companion object {
        fun imgToBase64String(img: HTMLCanvasElement): Promise<String>

        /**
         *
         * @param color {String} color like "#FFFFFF"
         * @return {String}
         */
        fun getIdealOutlineColor(color: Color): Color

        /**
         * Create a copy of the {@Color} object with the passed alpha value.
         * @param color {@Color} object used for RGB values
         * @param alpha {@float} value between 0 and 1
         * @return
         */
        fun setColorAlpha(color: Color, alpha: float): Color

        /**
         *
         * @param color
         * @param withAlpha
         * @return
         */
        fun colorToHexString(color: Color, withAlpha: Boolean): String

        /**
         * Clients should use getTextBounds
         * @param {String} fontName like "Arial" or "Arial, sans-serif" so a backup is
         * available in case 'Arial' is not present.
         * @param {Number} fontSize like 12
         * @param {String} fontStyle like "bold"
         * @param {String} text include if you want a width value.
         * @param {CanvasRenderingContext2D}
         * @returns {Object} {width:Number,height:Number,descent:Number,fullHeight:Number}
         */
        fun measureText(
            fontName: String,
            fontSize: int,
            fontStyle: String,
            text: String,
            context: CanvasRenderingContext2D
        ): Rectangle2D

        fun measureText(font: String, text: String, context: CanvasRenderingContext2D): Rectangle2D
        fun measureText(text: String, context: CanvasRenderingContext2D): Rectangle2D

        /**
         *
         * @param hexValue - String representing hex value (formatted "0xRRGGBB"
         * i.e. "0xFFFFFF") OR formatted "0xAARRGGBB" i.e. "0x00FFFFFF" for a color
         * with an alpha value I will also put up with "RRGGBB" and "AARRGGBB"
         * without the starting "0x" or "#"
         * @return
         */
        fun getColorFromHexString(hexValue: String): Color?

        /**
         * For Renderer Use Only
         * Assumes a fresh SVG String from the SVGLookup with its default values
         * @param symbolID
         * @param svg
         * @param strokeColor hex value like "#FF0000";
         * @param fillColor hex value like "#FF0000";
         * @return SVG String
         */
        fun setSVGFrameColors(symbolID: String, svg: String, strokeColor: Color, fillColor: Color): String
        fun setSVGSPCMColors(symbolID: String, svg: String, strokeColor: Color, fillColor: Color): String

        /**
         * For Renderer Use Only
         * Changes colors for single point control measures
         * @param symbolID
         * @param svg
         * @param strokeColor hex value like "#FF0000";
         * @param fillColor hex value like "#FF0000";
         * @param isOutline true if this represents a thicker outline to render first beneath the normal symbol (the function must be called twice)
         * @return SVG String
         *
         */
        fun setSVGSPCMColors(
            symbolID: String,
            svg: String,
            strokeColor: Color,
            fillColor: Color,
            isOutline: Boolean
        ): String

        fun findWidestStrokeWidth(svg: String): float
        fun getDistanceBetweenPoints(pt1: Point2D, pt2: Point2D): int
        fun scaleIcon(symbolID: String, icon: SVGInfo): SVGInfo
        fun getData(path: String): Promise<Any?>
    }
}

/**
 * This class is used for rendering icons that represent the single point graphics in the MilStd 2525.
 * It can also be used for rendering icon previews for multipoint graphics.
 */
external class MilStdIconRenderer {
    fun isReady(): Boolean

    /**
     * Checks symbol codes and returns whether they can be rendered.
     * For multi-point graphics, modifiers are ignored because we don't need that
     * information to show preview icons in the SymbolPicker.
     *
     * @param symbolID 20-30 digit 2525D Symbol ID Code
     * @param attributes (currently unused)
     * @return true if the basic form of the graphic can be rendered
     */
    fun CanRender(symbolID: String, attributes: JsReadonlyMap<String, String>): Boolean
    fun RenderSVG(
        symbolID: String,
        modifiers: JsReadonlyMap<String, String>,
        attributes: JsReadonlyMap<String, String>
    ): SVGSymbolInfo?
    fun AddCustomSymbol(msInfo: MSInfo, svgInfo: SVGInfo): Boolean

    companion object {
        fun getInstance(): MilStdIconRenderer
    }
}

/**
 * Main class for rendering multi-point graphics such as Control Measures, Atmospheric, and Oceanographic.
 *
 */
external class WebRenderer {
    /**
     * Given a symbol code meant for a single point symbol, returns the
     * anchor point at which to display that image based off the image returned
     * from the URL of the SinglePointServer.
     *
     * @param symbolID - the 20-30 digit symbolID of a single point MilStd2525
     * symbol.
     * @return A pixel coordinate of the format "x,y".
     * Returns an empty string if an error occurs.
     * @deprecated
     */
    fun getSinglePointAnchor(symbolID: String): String

    companion object {
        val OUTPUT_FORMAT_KML: Any? /* type isn't declared */

        /**
         * @deprecated
         */
        val OUTPUT_FORMAT_JSON: Any? /* type isn't declared */
        val OUTPUT_FORMAT_GEOJSON: Any? /* type isn't declared */
        val OUTPUT_FORMAT_GEOSVG: Any? /* type isn't declared */
        val MIN_ALT_DEFAULT: double
        val MAX_ALT_DEFAULT: double
        val RADIUS1_DEFAULT: double
        val RADIUS2_DEFAULT: double
        val LEFT_AZIMUTH_DEFAULT: double
        val RIGHT_AZIMUTH_DEFAULT: double
        val ERR_ATTRIBUTES_NOT_FORMATTED: String
        val DEFAULT_ATTRIBUTES: String

        /**\
         * Set minimum level at which an item can be logged.
         * In descending order:
         * OFF = Integer.MAX_VALUE
         * Severe = 1000
         * Warning = 900
         * Info = 800
         * Config = 700
         * Fine = 500
         * Finer = 400
         * Finest = 300
         * All = Integer.MIN_VALUE
         * Use like WebRenderer.setLoggingLevel(Level.INFO);
         * or
         * Use like WebRenderer.setLoggingLevel(800);
         */
        fun setLoggingLevel(level: LogLevel): Unit

        /**\
         * Set minimum level at which an item can be logged.
         * In descending order:
         * OFF = Integer.MAX_VALUE
         * Severe = 1000
         * Warning = 900
         * Info = 800
         * Config = 700
         * Fine = 500
         * Finer = 400
         * Finest = 300
         * All = Integer.MIN_VALUE
         * Use like WebRenderer.setLoggingLevel(Level.INFO);
         * or
         * Use like WebRenderer.setLoggingLevel(800);
         */
        fun setLoggingLevel(level: int): Unit

        /**
         * Single Point Tactical Graphics are rendered from font files.
         * The font size you specify here determines how big the symbols will
         * be rendered.  This should be set once at startup.
         * @param size
         */
        fun setTacticalGraphicPointSize(size: int): Unit

        /**
         * Units are rendered from font files.
         * The font size you specify here determines how big the symbols will
         * be rendered.  This should be set once at startup.
         * @param size
         */
        fun setUnitPointSize(size: int): Unit
        /**
         * Modifier Text Color will by default match the line color.
         * This will override all modifier text color.
         * @param hexColor
         */
        /**
         * Renders all multi-point symbols, creating KML that can be used to draw
         * it on a Google map.  Multipoint symbols cannot be draw the same
         * at different scales. For instance, graphics with arrow heads will need to
         * redraw arrowheads when you zoom in on it.  Similarly, graphics like a
         * Forward Line of Troops drawn with half circles can improve performance if
         * clipped when the parts of the graphic that aren't on the screen.  To help
         * readjust graphics and increase performance, this function requires the
         * scale and bounding box to help calculate the new locations.
         * @param id A unique identifier used to identify the symbol by Google map.
         * The id will be the folder name that contains the graphic.
         * @param name a string used to display to the user as the name of the
         * graphic being created.
         * @param description a brief description about the graphic being made and
         * what it represents.
         * @param symbolCode A 20-30 digit symbolID corresponding to one of the
         * graphics in the MIL-STD-2525D
         * @param controlPoints The vertices of the graphics that make up the
         * graphic.  Passed in the format of a string, using decimal degrees
         * separating lat and lon by a comma, separating coordinates by a space.
         * The following format shall be used "x1,y1[,z1] [xn,yn[,zn]]..."
         * @param altitudeMode Indicates whether the symbol should interpret
         * altitudes as above sea level or above ground level. Options are
         * "clampToGround", "relativeToGround" (from surface of earth), "absolute"
         * (sea level), "relativeToSeaFloor" (from the bottom of major bodies of
         * water).
         * @param scale A number corresponding to how many meters one meter of our
         * map represents. A value "50000" would mean 1:50K which means for every
         * meter of our map it represents 50000 meters of real world distance.
         * @param bbox The viewable area of the map.  Passed in the format of a
         * string "lowerLeftX,lowerLeftY,upperRightX,upperRightY." Not required
         * but can speed up rendering in some cases.
         * example: "-50.4,23.6,-42.2,24.2"
         * @param modifiers {@link Map}, keyed using constants from Modifiers.
         * Pass in comma delimited String for modifiers with multiple values like AM, AN &amp; X
         * @param attributes {@link Map}, keyed using constants from MilStdAttributes.
         * @param format An enumeration: 2 for GeoJSON.
         * @return A JSON string representation of the graphic.
         */
        fun RenderSymbol(
            id: String,
            name: String,
            description: String,
            symbolCode: String,
            controlPoints: String,
            altitudeMode: String,
            scale: double,
            bbox: String,
            modifiers: JsReadonlyMap<String, String>,
            attributes: JsReadonlyMap<String, String>,
            format: int
        ): String

        /**
         * Renders all multi-point symbols, creating KML or JSON for the user to
         * parse and render as they like.
         * This function requires the bounding box to help calculate the new
         * locations.
         * @param id A unique identifier used to identify the symbol by Google map.
         * The id will be the folder name that contains the graphic.
         * @param name a string used to display to the user as the name of the
         * graphic being created.
         * @param description a brief description about the graphic being made and
         * what it represents.
         * @param symbolCode A 20-30 digit symbolID corresponding to one of the
         * graphics in the MIL-STD-2525D
         * @param controlPoints The vertices of the graphics that make up the
         * graphic.  Passed in the format of a string, using decimal degrees
         * separating lat and lon by a comma, separating coordinates by a space.
         * The following format shall be used "x1,y1 [xn,yn]..."
         * @param pixelWidth pixel dimensions of the viewable map area
         * @param pixelHeight pixel dimensions of the viewable map area
         * @param bbox The viewable area of the map.  Passed in the format of a
         * string "lowerLeftX,lowerLeftY,upperRightX,upperRightY."
         * example: "-50.4,23.6,-42.2,24.2"
         * @param modifiers {@link Map}, keyed using constants from Modifiers.
         * Pass in comma delimited String for modifiers with multiple values like AM, AN &amp; X
         * @param attributes {@link Map}, keyed using constants from MilStdAttributes.
         * @param format An enumeration: 2 for GeoJSON.
         * @return A JSON (1) or KML (0) string representation of the graphic.
         */
        fun RenderSymbol2D(
            id: String,
            name: String,
            description: String,
            symbolCode: String,
            controlPoints: String,
            pixelWidth: int,
            pixelHeight: int,
            bbox: String,
            modifiers: JsReadonlyMap<String, String>,
            attributes: JsReadonlyMap<String, String>,
            format: int
        ): String

        /**
         * Renders all MilStd 2525 multi-point symbols, creating MilStdSymbol that contains the
         * information needed to draw the symbol on the map.
         * DOES NOT support RADARC, CAKE, TRACK etc...
         * ArrayList&lt;Point2D&gt; milStdSymbol.getSymbolShapes[index].getPolylines()
         * and
         * ShapeInfo = milStdSymbol.getModifierShapes[index].
         *
         *
         * @param id
         *            A unique identifier used to identify the symbol by Google map.
         *            The id will be the folder name that contains the graphic.
         * @param name
         *            a string used to display to the user as the name of the
         *            graphic being created.
         * @param description
         *            a brief description about the graphic being made and what it
         *            represents.
         * @param symbolCode
         *            A 20-30 digit symbolID corresponding to one of the graphics
         *            in the MIL-STD-2525D
         * @param controlPoints
         *            The vertices of the graphics that make up the graphic. Passed
         *            in the format of a string, using decimal degrees separating
         *            lat and lon by a comma, separating coordinates by a space. The
         *            following format shall be used "x1,y1[,z1] [xn,yn[,zn]]..."
         * @param altitudeMode
         *            Indicates whether the symbol should interpret altitudes as
         *            above sea level or above ground level. Options are
         *            "clampToGround", "relativeToGround" (from surface of earth),
         *            "absolute" (sea level), "relativeToSeaFloor" (from the bottom
         *            of major bodies of water).
         * @param scale
         *            A number corresponding to how many meters one meter of our map
         *            represents. A value "50000" would mean 1:50K which means for
         *            every meter of our map it represents 50000 meters of real
         *            world distance.
         * @param bbox
         *            The viewable area of the map. Passed in the format of a string
         *            "lowerLeftX,lowerLeftY,upperRightX,upperRightY." Not required
         *            but can speed up rendering in some cases. example:
         *            "-50.4,23.6,-42.2,24.2"
         * @param modifiers
         *            Used like:
         *            modifiers.set(Modifiers.T_UNIQUE_DESIGNATION_1, "T");
         *            Or
         *            modifiers.set(Modifiers.AM_DISTANCE, "1000,2000,3000");
         * @param attributes
         * 			  Used like:
         *            attributes.set(MilStdAttributes.LineWidth, "3");
         *            Or
         *            attributes.set(MilStdAttributes.LineColor, "#00FF00");
         * @return MilStdSymbol
         */
        fun RenderMultiPointAsMilStdSymbol(
            id: String,
            name: String,
            description: String,
            symbolCode: String,
            controlPoints: String,
            altitudeMode: String,
            scale: double,
            bbox: String,
            modifiers: JsReadonlyMap<String, String>,
            attributes: JsReadonlyMap<String, String>
        ): MilStdSymbol

        /**
         * Given a symbol code meant for a single point symbol, returns the
         * anchor point at which to display that image based off the image returned
         * from the URL of the SinglePointServer.
         *
         * @param symbolID - the 20-30 digit symbolID of a single point MilStd2525
         * symbol.
         * @return A pixel coordinate of the format "anchorX,anchorY,SymbolBoundsX,
         * SymbolBoundsY,SymbolBoundsWidth,SymbolBoundsHeight,IconWidth,IconHeight".
         * Anchor, represents the center point of the core symbol within the image.
         * The image should be centered on this point.
         * Symbol bounds represents the bounding rectangle of the core symbol within
         * the image.
         * IconWidth/Height represents the height and width of the image in its
         * entirety.
         * Returns an empty string if an error occurs.
         * @deprecated
         */
        fun getSinglePointInfo(symbolID: String): String

        /**
         * Returns true if we recommend clipping a particular symbol.
         * Would return false for and Ambush but would return true for a Line of
         * Contact due to the decoration on the line.
         * @param symbolID
         * @return
         */
        fun ShouldClipMultipointSymbol(symbolID: String): String

        /**
         * Given a symbol code meant for a single point symbol, returns the
         * symbol as a byte array.
         *
         * @param symbolID - the 20-30 digit symbolID of a single point MilStd2525
         * symbol.
         * @return byte array.
         * @deprecated
         */
        fun getSinglePointByteArray(symbolID: String): Nothing?

        /**
         * Converts a rectangle with two points and a width to a polygon that contains the four corners of the rectangle
         *
         * @param endpoints the two end points of the rectangle
         * @param width  the width of the rectangle
         * @returns the points of a polygon containing the four points of a rectangle
         */
        fun getRectangleCorners(endpoints: String, width: Number): String
    }
}

/**
 * Loads files needed by the renderer and initializes its data.
 * Required call before any rendering.
 * Must wait for the returned promise to resolve before any rendering.
 * @param location where renderer and asset files are location.  So if location is "127.0.0.1:8080/dist/C5Ren.js"
 * pass in "/dist/".  This is needed when all the files aren't in the same location.  When the renderer gets imported, it thinks it's
 * in the location of the file that imported it, not where it actually exists and then it can't find the asset files.  If location is not
 * set, the renderer assumes the json asset files are in the same location as where the C5Ren script is being run.
 */
external fun initialize(location: String = definedExternally): Promise<Any?>

/**
 * Returns true if renderer files are loaded and initialized.
 * @returns boolean
 */
external fun isReady(): Boolean

/* export {}; */
